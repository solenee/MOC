----------------------------------------------------------------------------------------------------------
-- Grammaires de MC et MOC                         --
-- La grammaire de MOC est obtenue en decommentant --
-- les parties indiquees.                          --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;

-- verification du retour 
inh typeRet : DTYPE for BLOC, INSTS, INST, SIX;
syn isRet   : BOOLEAN for BLOC, INSTS, INST, SIX;
-- decl type 
inh tInt  : DTYPE for PARFS, PARFSX, PARF, TYPE, STYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F;--, ARGS, ARGSX;
inh tChar : DTYPE for PARFS, PARFSX, STYPE, PARF, TYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F;--, ARGS, ARGSX;
inh tPointeurNull : DTYPE for PARFS, PARFSX, TYPE, PARF,  STYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F;--, ARGS, ARGSX;
inh tVoid  : DTYPE for PARFS, PARFSX, STYPE, ENTITES, TYPE, PARF, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F;--, ARGS, ARGSX;
inh regLB : Register for PARFS, PARFSX, TYPE, PARF,  STYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F;--, ARGS, ARGSX;
--attributes 
syn type  : DTYPE for TYPE, REFS, STYPE, F, E, A, T, R, AFFX;
inh htype : DTYPE for REFS;
-- affectation 
syn affectable : BOOLEAN for F, A, R, T, E;
syn vide       : BOOLEAN for TX, RX, AX, AFFX;
syn estAffectation : BOOLEAN for AFFX;

-- initialisation 
   
-- la table de symboles
inh tds  : TDS for ENTITES, FONCTION, PARFS, PARF, PARFSX, TYPE, REFS, 
                   STYPE, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F;--, ARGS, ARGSX;
syn stds : TDS for INST;
-- la table de symboles des fonctions
inh tds_fonction  : TDS for ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F;--, ARGS, ARGSX;
syn stds_fonction : TDS for FONCTION, ENTITES;
-- la liste de parametres
inh hparams : PARAMETRES for PARFS, PARF, PARFSX;--, ARGS, ARGSX;
syn params  : PARAMETRES for PARFS, PARF, PARFSX;--, ARGS, ARGSX;
-- la liste des parametres à mettre dans la tds du bloc associé à la fonction
inh htdspar : TDS for PARFS, PARF, PARFSX;
syn tdspar  : TDS for PARFS, PARF, PARFSX;
-- l'adresse des variables
inh hadr : INTEGER for ENTITES, FONCTION, PARFS, PARF, PARFSX, BLOC, INSTS, INST, SIX;
syn adr  : INTEGER for PARF, INST, INSTS;
syn last_adr : INTEGER for PARFS, PARFSX; -- vaut l'adresse du dernier parametre
inh htailleparams : INTEGER for BLOC, INSTS, INST, SIX;
-- le fichier source
inh source : MOCSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX,-- ARGS,ARGSX, 
         E, AFFX, A, AX, R, RX, T, TX, F
--         -- decommenter la ligne suivante pour MOC
--       ,IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS
--         -- fin extension MOC
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;
-- code genere
syn code : STRING for ENTITES, FONCTION, BLOC, INSTS, INST, SIX, E, A, AFFX, AX, R, RX, T, TX, F;
-- operation
inh hcode : STRING for AX, RX, TX;
inh code_gauche: STRING for AFFX; -- code du terme a gauche de l'operateur

--terminaux
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar retour is  "return";
sugar null is  "NULL";
sugar nil is  "nil";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";


term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
-- --decommenter pour MOC
--term identc is  "[A-Z][_0-9A-Za-z]*";   -- nom de classe
--term chaineo is  "@\"[^\"]*\"";         -- chaine MOC
-- --fin extension MOC

-- pour les instructions en assembleur 'inline'
compil ASM;

--production rules
PROGRAMME -> #initType #init #tds #adresse ENTITES #main #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#initType { 
do 
  ENTITES^tInt := new DTYPE("int", 1);
  ENTITES^tChar   := new DTYPE("char", 1);
  ENTITES^tPointeurNull := new POINTEURNULL();
  ENTITES^tVoid := new DTYPE("void", 0);
  ENTITES^regLB := new Register("LB", 0);
end 
}

#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
--tds associées à entites
#tds {
local
do
    ENTITES^tds := nil;
    ENTITES^tds_fonction := new TDS();
end
}   
--adresse de l'entité d'origine
#adresse {
do
  ENTITES^hadr := 0;
end
}
--verifie l'existence d'une fonction main
#main {
local
  i : INFO;
do
  i := ENTITES^stds_fonction.chercherLocalement("main");
  if (i = null) then
    error(NO_MAIN,"");
  end
end
}
-- ecrit le code dans un fichier
#gen {
local
do
    machine.writeCode(PROGRAMME^source.getFileName(), machine.genLabel()+ ENTITES^code + "\n;"); 
end
}
ENTITES -> #tds_fonction #gen ;
#gen {
do
  ENTITES^code := "";
end
}
#tds_fonction {
do
  ENTITES^stds_fonction := ENTITES^tds_fonction;
end
}  

ENTITES ->   asm #tds ASM ENTITES #tds_fonction #gen;
#tds {
do
  ENTITES1^tds := ENTITES^tds;
  -- Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MOC
  ASM^tds_asm := ENTITES^tds; 
end
}
#tds_fonction {
do
  ENTITES^stds_fonction := ENTITES1^stds_fonction;
end
}
#gen {
do
  ENTITES^code := ENTITES^machine.genCodeInLine(ASM^code_asm) + ENTITES1^code;-- ASM^code_asm contient le code ASM inline;
end
}

ENTITES ->  FONCTION #tds_fonction ENTITES #stds_fonction #gen ;
#tds_fonction {
do
  ENTITES1^tds_fonction := FONCTION^stds_fonction;
end
}
#stds_fonction {
do
  ENTITES^stds_fonction := ENTITES1^stds_fonction;
end
}
#gen {
do
  ENTITES^code := FONCTION^code + ENTITES1^code;
end
}

--fonctions
FONCTION ->  TYPE ident  paro #params #adresse PARFS parf #tds #passeTypeRet #passeTailleparams BLOC #tds_fonction #verifReturn #aff #gen ;
global
    tailleparams : INTEGER;

#passeTailleparams{
do
  tailleparams := - PARFS^last_adr -1;
  BLOC^htailleparams := tailleparams;
end
}
#aff {
do
  write "\n";
  write "\n";
  write "Table des fonctions visibles par " + ident^txt;
  write "\n";
  write FONCTION^tds_fonction.toString();
  --write "\n";
end
}
#gen {
do
  write "Taille des parametres de " + ident^txt + " : "+ tailleparams +"\n";
  FONCTION^code := FONCTION^machine.genFonction(ident^txt, BLOC^code);
end
}
#verifReturn {
do
   if ~TYPE^type.isVoid() & ~BLOC^isRet then 
      error(B_22, "vous avez oublie le retour");
   end   
end 
}
#params {
do
  PARFS^hparams := new PARAMETRES();		-- creation du conteneur des parametres
  PARFS^htdspar := new TDS(FONCTION^tds);       -- creation de la tds de la fonction 
end
}
#adresse {
do
  PARFS^hadr := -1;  				-- initialisation des adresses parametre
  BLOC^hadr := 3;				-- initialisation des adresse de bloc
end
}
#tds {
do
  BLOC^tds := PARFS^tdspar; 
end
}
#passeTypeRet {
do 
    BLOC^typeRet := TYPE^type;
end 
}
#tds_fonction {
local
  i : INFOFONCTION;
  t : TDS;
  s : String;
do
  i := new INFOFONCTION(TYPE^type, PARFS^params);
  t := FONCTION^tds_fonction;
  s := "Already_declared";
  if (t.chercherLocalement(ident^txt) != null) then
        error(B_01, "fonction deja existante");   -- write fonction existante
  else
    t.inserer(ident^txt, i);
  end
  FONCTION^stds_fonction := t;
end
}

-- parametres de fonctions
PARFS ->  #params #last_adr;
#params {
do
  PARFS^params := PARFS^hparams;
  PARFS^tdspar := PARFS^htdspar;
end
}
#last_adr {
do
  PARFS^last_adr := PARFS^hadr;
end
}

PARFS -> PARF #params1 #adresse PARFSX #params2 #last_adr;
#params1 {
do
  PARFSX^hparams := PARF^params;
  PARFSX^htdspar := PARF^tdspar;
end
}
#adresse {
do
  PARFSX^hadr := PARF^adr;
end
}
#params2 {
do
  PARFS^params := PARFSX^params;
  PARFS^tdspar := PARFSX^tdspar;
end
}
#last_adr {
do
  PARFS^last_adr := PARFSX^last_adr;
end
}

PARFSX ->  #params #last_adr;
#params {
do
  PARFSX^params := PARFSX^hparams;
  PARFSX^tdspar := PARFSX^htdspar;
end
}
#last_adr {
do
  PARFSX^last_adr := PARFSX^hadr;
end
}

PARFSX ->  virg PARF #params1 #adresse PARFSX #params2 #last_adr;
#params1 {
do
  PARFSX1^hparams := PARF^params;
  PARFSX1^htdspar := PARF^tdspar;
end
}
#adresse {
do
  PARFSX1^hadr := PARF^adr;
end
}
#params2 {
do
  PARFSX^params := PARFSX1^params;
  PARFSX^tdspar := PARFSX1^tdspar;
end
}
#last_adr {
do
  PARFSX^last_adr := PARFSX1^last_adr;
end
}

PARF ->  TYPE ident #params #adresse;
#params {
local
  p : PARAMETRES;
  i : INFOVAR;
  t : TDS;
do
  i := new INFOVAR(TYPE^type, new Emplacement(PARF^hadr, PARF^regLB));
  p := PARF^hparams;
  p.inserer(TYPE^type);
  PARF^params := p;
  t := PARF^htdspar;
  if (t.chercherLocalement(ident^txt) = null) then
    t.inserer(ident^txt, i);
  else
        error(B_02, "nom de parametre deja existant ");   -- write fonction existante
    -- write nom de parametre deja utilise
  end
  PARF^tdspar := t;
end
}
#adresse {
local
  taille : INTEGER;
do
  taille := TYPE^type.getTaille();
  PARF^adr := PARF^hadr - taille;
end
}

-- les types (de base et pointeurs)
TYPE -> STYPE #recapTypePointeur  REFS #creatType ;
#creatType {
do
	TYPE^type := REFS^type;
end
}

#recapTypePointeur {
do
	REFS^htype := STYPE^type;
end
}

REFS -> #syntheseType ;
#syntheseType{
do 
	REFS^type := REFS^htype;
end
}

REFS -> mult #recapType REFS #creatType ;
#recapType{
do
	REFS1^htype := REFS^htype;
end
}

#creatType{
do 
	REFS^type := new POINTEUR(REFS1^type);
end
}

-- types de base
STYPE-> void #creatType ;
#creatType {
do
	STYPE^type := STYPE^tVoid;
end
}

STYPE-> int  #creatType ;
#creatType {
do
	STYPE^type := STYPE^tInt;
end
}

STYPE-> char  #creatType ;
#creatType {
do
	STYPE^type := STYPE^tChar;
end
}

-- corps de methode et bloc d'instructions
BLOC ->  aco #tds #passeTypeRet INSTS acf #isReturn #gen ;
global        
  t : TDS;
#tds {
do
   t :=  new TDS(BLOC^tds);
   INSTS^tds := t;
end
}
#passeTypeRet {
do 
   INSTS^typeRet := BLOC^typeRet;
end 
}
#isReturn {
do
   BLOC^isRet := INSTS^isRet;
end 
}
#gen {
local 
    tailleBloc : INTEGER;
do
   tailleBloc := INSTS^adr - BLOC^hadr;
   write "; tds:\n" + t;
   write "; taille des locales = " + tailleBloc+ "\n";
   -- Le code du bloc est celui de ses instructions
   -- plus le code pour liberer la place occupee
   -- par les variables locales (POP (0) taille)
   BLOC^code := INSTS^code + BLOC^machine.genFree(tailleBloc) ;
end
}

-- instructions
INSTS ->  #isReturn #adr #gen;
#adr {
do
  INSTS^adr := INSTS^hadr;
end
}
#isReturn{
do 
   INSTS^isRet := false;
end
}
#gen {
do
    -- no code
    INSTS^code := "";
end
}

INSTS -> #passeType INST #tds #adresse INSTS #isReturn #adr #gen ;
#passeType {
do
   INST^typeRet := INSTS^typeRet;
   INSTS1^typeRet := INSTS^typeRet;
end 
}
#tds {
do
  INSTS1^tds := INST^stds;
end
}
#adresse {
do
  INSTS1^hadr := INST^adr;
end
}
#isReturn {
do 
  INSTS^isRet := INST^isRet | INSTS1^isRet;
end
}
#adr {
do
  INSTS^adr := INSTS1^adr;
end
}
#gen {
do
    -- append codes
    INSTS^code := INST^code + INSTS1^code;
end
}

-- declaration de variable locale avec ou sans init
INST ->  TYPE ident #tds #adresse #code_gauche AFFX pv  #verifCompatibilite #isReturn #gen ;
global
  i : INFO;
#tds {
do
  i := INST^tds.chercherLocalement(ident^txt);
  if (i != null) then
        error(B_03, "nom de variable deja utilise ");   -- write fonction existante
    -- write nom de variable deja utilise
  else
    i := new INFOVAR(TYPE^type, new Emplacement(INST^hadr, INST^regLB));
    INST^tds.inserer(ident^txt, i);
  end
  INST^stds := INST^tds;
end
}
#adresse {
do
  INST^adr := INST^hadr + TYPE^type.getTaille();
end
}
#code_gauche {
do
   AFFX^code_gauche := INST^machine.genDeclaration(ident^txt, TYPE^type.getTaille());
end
}
#verifCompatibilite {
local 
   compValue : BOOLEAN;
do
	if AFFX^type != null then
		compValue := TYPE^type.compareTo(AFFX^type);
		if ~compValue then 
			error(B_04 , "affectation non compatible");
		end 
	end
end  
}
#isReturn{
do 
   INST^isRet := false;
end 
}
#gen {
do
    INST^code := AFFX^code;
end
}

-- instruction expression (affectation et appel de procedure)
INST -> E pv #adresse #stds #isReturn #gen ;
#gen {
do
    -- consommer la valeur si elle existe
    INST^code := ";E^code" + INST^machine.genFree(E^type.getTaille());
end
}

#adresse {
do
  INST^adr := INST^hadr;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#isReturn{ 
do
   INST^isRet := false;
end
}

-- bloc d'instructions
INST ->  #passeTypeRet #tds BLOC #adresse #stds #isReturn #gen ;
#passeTypeRet{
do
   BLOC^typeRet := INST^typeRet;
end
}
#adresse {
do
  INST^adr := INST^hadr;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#tds {
do
  --BLOC^tds := new TDS(INST^tds);
end
}
#isReturn{ 
do
   INST^isRet := false;
end
}
#gen {
do
    INST^code := BLOC^code;
end
}

-- conditionnelle
INST ->   si paro E parf #tds #passeTypeRet BLOC SIX #adresse #stds #isReturn #gen;
#passeTypeRet{
do
   BLOC^typeRet := INST^typeRet;
   SIX^typeRet := INST^typeRet;
end 
}
#adresse {
do
  INST^adr := INST^hadr;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#tds {
do
  BLOC^tds := new TDS(INST^tds);
end
}
#isReturn {
do
  INST^isRet := BLOC^isRet & SIX^isRet;
end
}
#gen {
do
    write "code de la condition : "+ E^code;
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code);
end
}

SIX ->    sinon #tds #passeTypeRet BLOC #isReturn #gen;
#tds {
do
  BLOC^tds := new TDS(SIX^tds);
end
}
#passeTypeRet {
do
   BLOC^typeRet := SIX^typeRet;
end
}
#isReturn {
do
   SIX^isRet := BLOC^isRet;
end 
}
#gen {
do
    SIX^code := BLOC^code; 
end
}

SIX -> #isReturn #gen ;
#isReturn {
do
   SIX^isRet := false;
end 
}
#gen {
do
    SIX^code := ""; 
end
}

-- retour de fonction
INST ->  retour  E pv #adresse #tds #verifReturn #isReturn #gen ;
#adresse {
do
  INST^adr := INST^hadr;
end
}
#tds {
do
  INST^stds := INST^tds;
end
}
#verifReturn {
do
   if ~INST^typeRet.compareTo(E^type) then 
      error(B_21, "faux retour");
   end 
end 
}
#isReturn {
do
   INST^isRet := true;
end 
}
#gen {
do
  -- sortir de la fonction courante en retournant la valeur de E
  INST^code := INST^machine.genRetour(INST^htailleparams, E^type.getTaille(), E^code);
end
}

-- inline asm
INST ->  asm   #tds ASM #adresse #stds #isReturn #gen;
#adresse {
do
  INST^adr := INST^hadr;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds; 
end
}
#isReturn {
do
   INST^isRet := false;
end 
}
#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
   INST^code := INST^machine.genCodeInLine(ASM^code_asm);
end
}

-- les expressions
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
-- ici je demande est ce que j ai besoin de verifier la compatibilite des types 
-- Si AFFX^type est nul alors pas besoin de verifier 
E ->   A #code_gauche AFFX #verifCompatible #getType #estAffectable #gen ;
#code_gauche {
do
    AFFX^code_gauche := A^code;
end
}
#verifCompatible {
local 
   compValue : BOOLEAN;
do
	if ~AFFX^vide then
		compValue := A^type.compareTo(AFFX^type);
		if ~compValue then 
			error(B_6 , "affectation : type non compatible");
			-- ecrire erreur de typage d affectation 
		end 
	end
end  
}
-- j affecte a E le type du cote gauche de l affectation 
#getType {
do
	E^type := A^type;
end
}
#estAffectable{
do
   if AFFX^vide then
       E^affectable := A^affectable;
   else 
       E^affectable := false; 
   end  
end 
}
#gen {
do
  if AFFX^estAffectation then
    if ~A^affectable then
        error(NonAffectable , "Le cote gauche n est pas affectable");
    end
  end
  E^code := AFFX^code;
end 
}

-- affectation  : laisse en somment de pile la valeur affectee
---AFFX -> affect A #getType #estVide #gen ;
--#getType {
--do 
--   AFFX^type := A^type;
--end 
--}
---#estVide{
--do
--   AFFX^vide := false;
--end 
--}
---#gen {
--do
    -- to do : mettre en sommet de pile la valeur de A 
--    AFFX^code := AFFX^machine.genAffectation(AFFX^code_gauche, A^code);
--end
--}

AFFX ->  #getType #estVide #gen ;
#getType {
do 
	AFFX^type := null;
end 
}
#estVide{
do
   AFFX^vide := true;
end 
}
#gen {
do
    -- to do
    AFFX^estAffectation := false;
    AFFX^code := AFFX^code_gauche;
end
}

-- relation
A ->   R #hcode AX  #verifType #getType #estAffectable #gen;
#hcode {
do
  AX^hcode := R^code;
end
}
#verifType {
do
   if ~AX^vide then 
	  if ~R^type.isOperable() then 
		error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
	  end
   end 
end 
}
#getType{
do
	if AX^vide then 
		A^type := R^type;
	else 
		A^type := A^tInt;
	end 
   
end 
}
#estAffectable {
do 
	if AX^vide then 
		A^affectable := R^affectable;
	else 
		A^affectable := false;
	end 
end 
}
#gen {
do
  A^code := AX^code;
end
}

AX -> #extension #gen;
#extension{
do 
   AX^vide := true; 
end 
}
#gen {
do
  AX^code := AX^hcode;
end
}

R ->  T #hcode RX #verifType #getType #estAffectable #gen;
#verifType {
do
  if ~RX^vide then 
	if ~T^type.isOperable() then 
		error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
	end
  end 
end 
}
#getType{
do
	if RX^vide then 
		R^type := T^type;
	else 
		R^type := R^tInt;
	end 
   
end 
}
#estAffectable {
do 
	if RX^vide then 
		R^affectable := T^affectable;
	else 
		R^affectable := false;
	end 
end 
}
#hcode {
do
   RX^hcode := T^code;
end
}
#gen {
do
   R^code := RX^code;
end
}

RX -> #extension #gen;
#extension {
do
   RX^vide := true; 
end
}
#gen {
do
  RX^code := RX^hcode;
end
}

-- multiplication, ...
T ->  F #hcode TX   #verifType #getType #estAffectable #gen ;
#hcode {
do
   TX^hcode := F^code;
end
}
#verifType {
do
  if ~ TX^vide then 
	if ~F^type.isOperable() then 
		error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
	end
 end 
end 
}
#getType{
do
   if TX^vide then 
		T^type := F^type;
	else 
		T^type := T^tInt;
	end 
end 
}
#estAffectable {
do 
	if TX^vide then 
		T^affectable := F^affectable;
	else 
		T^affectable := false;
	end 
end 
}
#gen {
do 
    T^code := TX^code;
end
}

TX -> #extension #gen ;
#extension {
do
  TX^vide := true;
end 
}
#gen {
do
  TX^code := TX^hcode;
end
}

-- expressions de base
-- Constante entiere
F -> entier  #getType #estAffectable #gen;
#getType {
do
   F^type := F^tInt;
end 
}
#estAffectable{
do 
   F^affectable := false;
end 
}
#gen {
do
  F^code := F^machine.genEntier(entier^txt);
end
}

----====decommenter pour ============ MOC extension =================
--ENTITES ->  IMPLEMENTATION ENTITES ;
---- definition d'une classe
--IMPLEMENTATION ->  classe identc SUPER aco ATTRIBUTS acf METHODES fin ;
---- surclasse
--SUPER -> ;
--SUPER -> dpts identc  ;
----attributs
--ATTRIBUTS -> ;
--ATTRIBUTS -> TYPE ident pv ATTRIBUTS;
-- -- methodes
--METHODES -> ;
--METHODES ->  METHODE  METHODES ;
--METHODE ->  QUAL PTYPE   MPARFS BLOC ;
-- --qualificateur attribut ou methode :  + = de classe, - = d'instance
--QUAL -> plus;
--QUAL -> moins;
-- --type classe 
--STYPE-> identc ;
-- -- type BOOL
--STYPE-> bool ;
-- -- type "any"
--TYPE -> id  ;
---- type argument (ou retour) de methode entre parentheses
--PTYPE-> paro TYPE parf ;
---- parametres de methodes
--MPARFS -> ;
--MPARFS ->  MPARF MPARFS ;
-- -- selecteur sans parametre
--MPARF ->  ident  ;
-- -- selecteur  + type parametre + nom parametre
--MPARF ->   ident dpts  PTYPE ident;
---- object nil
--F -> nil   ;
----Constante 'YES'
--F -> yes   ;
---- Constante 'NO'
--F -> no   ;
-- -- chaine MOC (commence par @)
--F -> chaineo ;
--  --self = this de Java
--F -> self  ;
--F -> super  ;
-- -- Appel de methode
--F -> cro F MARGS crf   ;
---- pour appel methode de classe
--F -> cro identc MARGS crf  ;
---- arguments appel de methode
--MARGS ->   ;
--MARGS ->  MARG MARGS   ;
-- -- selecteur + arg
--MARG -> ident dpts  E;
-- -- selecteur sans arg
--MARG -> ident  ;
---- --fin de MOC extension

end
