-- affectation
E −> A affect R #gen
#gen {
do
    -- to do
    E^code := "; ? to do : -- affectation";
    calculer  -- ?
end
}

E −> A

-- relation
A −> R OPREL R  #gen;
#gen {
do
  A^code := R^code + R1^code + OPREL^code;
end
}
A −> R #gen;
#gen {
do
  A^code := R^code;
end
}



−− additions
R −> R OPADD T  #gen;
#gen {
do
  R^code := R1^code + T^OPREL^machine.genInf()";
end
}
R −> T  #gen;
#gen {
do
  R^code := T^code;
end
}
OPADD −> plus
OPADD −> moins
OPADD −> ou

−− multiplication
T −> T OPMUL F  #gen;
#gen {
do
  T^code := T1^code + F^code + OPMUL^code;
end
}
T −> F  #gen;
#gen {
do
  T^code := F^code;
end
}

-- expressions de base
−− Constante entiere
F −> entier  #gen;
#gen {
do
  F^type := new DTYPE("int", F^machine.getTaille("int"));
  F^code := F^machine.genConstante(entier^txt);
end
}
−− Constante chaine
F −> chaine #gen;
#gen {
do
  F^type := pointeur sur char;
  F^code := "chaine de caracteres "+chaine^txt; -- pointeur sur un tableau de caracteres
end
}
−− Constante  caractere
F −> caractere #gen;
#gen {
do
  F^type := new DTYPE("char", F^machine.getTaille("char"));
  F^code := F^machine.genConstante(caractere^txt);
end
}
−− expression unaire
F −> OPUN F  #gen;
#gen {
do
  T^code := F^code + OPUN^code;
end
}
OPUN −> plus
OPUN −> moins
OPUN −> non
−− pointeur nul
F −> null
−− expression parenthesee
F −> paro E parf  #gen;
#gen {
do
  T^code := E^code;
end
}
F −> paro TYPE parf  #gen;
#gen {
do
  T^code := TYPE^code;
end
}

−− access variable
F −> ident #gen;
global 
  iv : INFOVAR ;
  t : DTYPE;
#gen{
local
  i:INFO;
do
  i := F^tds.chercherGlobalement(ident^txt);
  if i = null then
    error(UndefinedVariable, ident^txt);
  end
  match i 
  with INFOVAR then
    iv := i;
    F^adr := iv.getDep();
    t := iv.getType();
    FACTEUR^type := t;
    -- commentaire laisse dans le code
    F^code := F^machine.genComment("\t; acces a " + ident^txt);
  else
    error(FunctionUsedAsVariable, ident^txt);
  end
end
}
−−−− acces zone pointee
F −> mult F 
