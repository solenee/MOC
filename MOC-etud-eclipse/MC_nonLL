-- affectation
E −> A affect R #gen
#gen {
do
    -- to do
    E^code := "; ? to do : -- affectation";
    calculer  -- ?
end
}

E −> A

-- relation
A −> R OPREL R  #gen;
#gen {
do
  A^code := R^code + R1^code + OPREL^code;
end
}
A −> R #gen;
#gen {
do
  A^code := R^code;
end
}

−− additions
R −> R OPADD T  #gen;
#gen {
do
  R^code := R1^code + T^code + OPADD^code;
end
}
R −> T  #gen;
#gen {
do
  R^code := T^code;
end
}
OPADD −> plus
OPADD −> moins
OPADD −> ou

−− multiplication
T −> T OPMUL F  #gen;
#gen {
local
--  t : STRING
  op : STRING; -- mult / div / mod / et
do
  op := OPUN^op;
--typeT = T.getType().getNom();
--typeF = F.getType().getNom()
=====================================================
  if op.equals("mult") then
    F^code := TF1^code; -- if t = "int" 
  elseif op.equals("moins") then
    F^code := F^machine.genIMoins(F1^code);
  elseif op.equals("non") then
    F^code := F^machine.genBNegation(F1^code);
  else
    error(DebugMessageOPUN, op);
  end
end
}

#gen {
do
  T^code := T1^code + F^code + OPMUL^code;
end
}
T −> F  #gen;
#gen {
do
  T^code := F^code;
end
}
