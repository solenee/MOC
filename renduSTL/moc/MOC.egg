----------------------------------------------------------------------------------------------------------
-- Grammaires de MC et MOC                         --
-- La grammaire de MOC est obtenue en decommentant --
-- les parties indiquees.                          --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2; 

-- compter les parametres pour le lovely init hhh
inh typeClasse : DTYPE for MPARFS, MPARF;
--syn tParam : INTEGER for MARGS, MARG; 
-- verification du retour 
inh typeRet : DTYPE for BLOC, INSTS, INST, SIX;
syn isRet   : BOOLEAN for BLOC, INSTS, INST, SIX;
-- decl type 
inh tInt  : DTYPE for PARFS, PARFSX, PARF, TYPE, STYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE;
inh tChar : DTYPE for PARFS, PARFSX, STYPE, PARF, TYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE;
inh tPointeurNull : DTYPE for PARFS, PARFSX, TYPE, PARF,  STYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE;
inh tVoid  : DTYPE for PARFS, PARFSX, STYPE, ENTITES, TYPE, PARF, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE;
inh tString : DTYPE for PARFS, PARFSX, STYPE, PARF, TYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE;
inh regLB : Register for PARFS, PARFSX, TYPE, PARF,  STYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE;
-- == moc
inh tBool :  DTYPE for PARFS, PARFSX, STYPE, PARF, TYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE; 
inh tNil :  DTYPE for PARFS, PARFSX, STYPE, PARF, TYPE, ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS, PTYPE;
-- =/= moc
--attributes  
syn type  : DTYPE for TYPE, REFS, STYPE, F, E, A, T, R, AFFX, PTYPE;
inh htype : DTYPE for REFS, AFFX;
-- affectation 
syn affectable : BOOLEAN for F, A, R, T, E;
syn vide       : BOOLEAN for TX, RX, AX, AFFX;
syn estAffectation : BOOLEAN for AFFX;
syn est_adresse : BOOLEAN for F, T, TX, A, E, RX, R, AX;--, T, F;
inh hest_adresse : BOOLEAN for AFFX, TX, RX, AX;
syn adresse : Emplacement for F, TX, T, A, E, RX, R, AX;
inh hadresse : Emplacement for AFFX, TX, RX, AX;
inh lire_resultat : BOOLEAN for E, AFFX; -- indique si AFFX doit generer le code pour lire le terme de gauche
-- initialisation  
   
-- la table de symboles
inh tds  : TDS for ENTITES, IMPLEMENTATION, FONCTION, SUPER, ATTRIBUTS, METHODES, METHODE, 
                          QUAL, MPARFS, MPARF, PARFS, PARF, PARFSX, TYPE, REFS, 
                          STYPE, PTYPE, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, 
                          MARG, MARGS, ARGS, ARGSX;
syn stds : TDS for INST;
-- la table de symboles des fonctions
inh tds_fonction  : TDS for ENTITES, FONCTION, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, ARGS, ARGSX, METHODES, METHODE, IMPLEMENTATION, MARG, MARGS;
syn stds_fonction : TDS for FONCTION, ENTITES;
----la table de symbole des classes
inh tds_classe : TDS for ENTITES, IMPLEMENTATION, FONCTION, SUPER, ATTRIBUTS, METHODES, METHODE, 
                          QUAL, MPARFS, MPARF, PARFS, PARF, PARFSX, TYPE, REFS, 
                          STYPE, PTYPE, BLOC, INSTS, INST, SIX, AFFX, E, A, AX, R, RX, T, TX, F, 
                          MARG, MARGS, ARGS, ARGSX;
syn stds_classe : TDS for IMPLEMENTATION, METHODES, METHODE;
----le nom de la methode
syn nom : String for MPARFS, MPARF, MARG, MARGS;
----qualificatif methode
syn qual : Boolean for QUAL;
----nom de la classe
inh classe : String for METHODES, METHODE, FONCTION, BLOC, INSTS, INST, SIX;
syn classe_mere : CLASSE for SUPER;
syn iclasse_mere : INFOCLASSE for SUPER;
inh hclasse_fille : String for SUPER;
----champs --= MODIF : ça existe deja : c'est (h)attributs
-- inh hlchamps : LCHAMPS for ATTRIBUTS;
-- syn lchamps : LCHAMPS for ATTRIBUTS;
----deplacement
inh hdep : int for ATTRIBUTS;
-- la liste de parametres
inh hparams : PARAMETRES for MPARFS, MPARF, PARFS, PARF, PARFSX, ARGS, ARGSX, MARGS, MARG;
syn params  : PARAMETRES for MPARFS, MPARF, PARFS, PARF, PARFSX, ARGS, ARGSX,MARGS, MARG;
-- la liste des parametres à mettre dans la tds du bloc associé à la fonction
inh htdspar : TDS for MPARFS, MPARF, PARFS, PARF, PARFSX;
syn tdspar  : TDS for MPARFS, MPARF, PARFS, PARF, PARFSX;
-- l'adresse des variables
inh hadr : INTEGER for ENTITES, FONCTION, MPARFS, MPARF,PARFS, PARF, PARFSX, BLOC, INSTS, INST, SIX;
syn adr  : INTEGER for MPARF, PARF, INST, INSTS;
syn last_adr : INTEGER for PARFS, PARFSX, MPARFS; -- vaut l'adresse du dernier parametre
inh htailleparams : INTEGER for BLOC, INSTS, INST, SIX;
-- le fichier source
inh source : MOCSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for  
         ENTITES, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ARGS,ARGSX, 
         E, AFFX, A, AX, R, RX, T, TX, F, OPMUL, OPUN, OPADD, OPREL
         -- decommenter la ligne suivante pour MOC
       ,IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS
        -- fin extension MOC
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;
-- code genere
syn code : STRING for ENTITES, FONCTION, BLOC, INSTS, INST, SIX, E, A, AFFX, AX, R, RX, T, TX, F, OPMUL, ARGS, ARGSX, OPUN, OPADD, OPREL, MARGS, MARG, METHODE, METHODES, IMPLEMENTATION;
-- operation
inh hcode : STRING for AX, RX, TX;
inh code_gauche: STRING for AFFX; -- code du terme a gauche de l'operateur
-- definition des classes
---- les attributs
inh hattributs : LCHAMPS for ATTRIBUTS;
syn attributs : LCHAMPS for ATTRIBUTS, SUPER;
-- type associe a la classe mere
-- syn tclasse_mere : CLASSE for SUPER;
inh emplNull : Emplacement for ENTITES, FONCTION, INST, BLOC, INSTS, SIX, PARFS, PARF, PARFSX, ARGS,ARGSX, E, AFFX, A, AX, R, RX, T, TX, F, OPMUL, OPUN, OPADD, OPREL
         -- decommenter la ligne suivante pour MOC
       ,IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS, MPARF, MPARFS,MARG, MARGS
         -- fin extension MOC
         ; 

--terminaux
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar retour is  "return";
sugar null is  "NULL";
sugar nil is  "nil";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";

-- MOC extension
sugar dpts is "\:";
sugar cro is "\[";
sugar crf is "\]";
sugar id is "id";
sugar classe is "@class";
sugar fin is "@end";
sugar self is "self";
sugar bool is "BOOL";
sugar super is "super";
sugar yes is "YES";
sugar no is "NO";


term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
--decommenter pour MOC
term identc is  "[A-Z][_0-9A-Za-z]*";   -- nom de classe
term chaineo is  "@\"[^\"]*\"";         -- chaine MOC
--fin extension MOC

-- pour les instructions en assembleur 'inline'
compil ASM;

--production rules
PROGRAMME -> #initType #init #initCode #tds #adresse ENTITES #main #gen; --======== MODIF
global
   machine : IMachine;
   leCode : STRING;
   tPNull : POINTEUR;
   emplPNull : Emplacement;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#initType { 
do 
  ENTITES^tInt := new DTYPE("int", 1);
  ENTITES^tChar   := new DTYPE("char", 1);
  ENTITES^tString   := new DTYPE("string", 1);
  ENTITES^tPointeurNull := new POINTEURNULL();
  ENTITES^tVoid := new DTYPE("void", 0);
  ENTITES^regLB := new Register("LB", 0);
  ENTITES^tNil := new OBJETNIL();
  ENTITES^tBool := new DTYPE("bool", 1);
  tPNull := new POINTEURNULL();
  ENTITES^tPointeurNull := tPNull;
end 
}

#init {
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}
#initCode {
do
  emplPNull := new Emplacement(0, new Register("SB", 0));
  ENTITES^emplNull := emplPNull;
  leCode := machine.genComment("code de lancement du programme") + machine.genEspaceNull() 
    + machine.genCallMain() + machine.genFinProgramme() ;
end
}
--tds associées à entites
#tds {
local
do
    ENTITES^tds := nil;
    ENTITES^tds_fonction := new TDS();
    ENTITES^tds_classe := new TDS();
end
}   
--adresse de l'entité d'origine
#adresse {
do
  ENTITES^hadr := 0;
end
}
--verifie l'existence d'une fonction main
#main {
local
  i : INFO;
do
  i := ENTITES^stds_fonction.chercherLocalement("main");
  if (i = null) then
    error(NO_MAIN,"");
  end
end
}
-- ecrit le code dans un fichier
#gen {
local
do
   leCode := leCode + machine.genComment("code source du programme\n\n\n") + ENTITES^code;
    machine.writeCode(PROGRAMME^source.getFileName(), leCode);
end
}
ENTITES -> #tds_fonction #aff #gen ;
#gen {
do
  ENTITES^code := "";
end
}
#tds_fonction {
do
  ENTITES^stds_fonction := ENTITES^tds_fonction;
end
}  
#aff {
do
  write "\n";
  write "\n";
  write "Ensembles des classes du programme : ";
  write "chargement...";
  write "\n";
  write ENTITES^tds_classe;
end
}

ENTITES ->   asm #tds ASM ENTITES #tds_fonction #gen;
#tds {
do
  ENTITES1^tds := ENTITES^tds;
  -- Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MOC
  ASM^tds_asm := ENTITES^tds; 
end
}
#tds_fonction {
do
  ENTITES^stds_fonction := ENTITES1^stds_fonction;
end
}
#gen {
do
  ENTITES^code := ENTITES^machine.genCodeInLine(ASM^code_asm) + ENTITES1^code;-- ASM^code_asm contient le code ASM inline;
end
}

ENTITES ->  #initClass FONCTION #tds_fonction ENTITES #stds_fonction #gen ;
#initClass {
do
   FONCTION^classe := null;
end
}
#tds_fonction {
do
  ENTITES1^tds_fonction := FONCTION^stds_fonction;
end
}
#stds_fonction {
do
  ENTITES^stds_fonction := ENTITES1^stds_fonction;
end
}
#gen {
do
  ENTITES^code := FONCTION^code + ENTITES1^code;
end
}

--fonctions
FONCTION ->  TYPE ident  paro #params #adresse PARFS parf #tds #passeTypeRet #passeTailleparams BLOC #tds_fonction #verifReturn #aff #gen ;
global
    tailleparams : INTEGER;
    tRetour : DTYPE;
    leCode : STRING;
#passeTailleparams{
do
  tailleparams := - PARFS^last_adr -1;
  BLOC^htailleparams := tailleparams;
end
}
#aff {
do
  write "\n";
  write "\n";
  write "Table des fonctions visibles par " + ident^txt;
  write "\n";
  write FONCTION^tds_fonction.toString();
  --write "\n";
end
}
#gen {
do
  write "Taille des parametres de " + ident^txt + " : "+ tailleparams +"\n";
  leCode := FONCTION^machine.genFonction(ident^txt, BLOC^code);
  tRetour := TYPE^type;
  if(tRetour.isVoid()) then
    -- depiler les arguments
    leCode := leCode + FONCTION^machine.genRetour(tailleparams, 0, "");
  end
  FONCTION^code := leCode;
end
}
#verifReturn {
do
   if ~TYPE^type.isVoid() & ~BLOC^isRet then 
      error(B_22, "vous avez oublie le retour");
   end   
end 
}
#params {
do
  PARFS^hparams := new PARAMETRES();		-- creation du conteneur des parametres
  PARFS^htdspar := new TDS(FONCTION^tds);       -- creation de la tds de la fonction 
end
}
#adresse {
do
  PARFS^hadr := -1;  				-- initialisation des adresses parametre
  BLOC^hadr := 3;				-- initialisation des adresse de bloc
end
}
#tds {
do
  BLOC^tds := PARFS^tdspar; 
end
}
#passeTypeRet {
do 
    BLOC^typeRet := TYPE^type;
end 
}
#tds_fonction {
local
  i : INFOFONCTION;
  t : TDS;
  s : String;
do
  i := new INFOFONCTION(TYPE^type, PARFS^params);
  t := FONCTION^tds_fonction;
  s := "Already_declared";
  if (t.chercherLocalement(ident^txt) != null) then
        error(B_01, "fonction deja existante");   -- write fonction existante
  else
    t.inserer(ident^txt, i);
  end
  FONCTION^stds_fonction := t;
end
}

-- parametres de fonctions
PARFS ->  #params #last_adr;
#params {
do
  PARFS^params := PARFS^hparams;
  PARFS^tdspar := PARFS^htdspar;
end
}
#last_adr {
do
  PARFS^last_adr := PARFS^hadr;
end
}

PARFS -> PARF #params1 #adresse PARFSX #params2 #last_adr;
#params1 {
do
  PARFSX^hparams := PARF^params;
  PARFSX^htdspar := PARF^tdspar;
end
}
#adresse {
do
  PARFSX^hadr := PARF^adr;
end
}
#params2 {
do
  PARFS^params := PARFSX^params;
  PARFS^tdspar := PARFSX^tdspar;
end
}
#last_adr {
do
  PARFS^last_adr := PARFSX^last_adr;
end
}

PARFSX ->  #params #last_adr;
#params {
do
  PARFSX^params := PARFSX^hparams;
  PARFSX^tdspar := PARFSX^htdspar;
end
}
#last_adr {
do
  PARFSX^last_adr := PARFSX^hadr;
end
}

PARFSX ->  virg PARF #params1 #adresse PARFSX #params2 #last_adr;
#params1 {
do
  PARFSX1^hparams := PARF^params;
  PARFSX1^htdspar := PARF^tdspar;
end
}
#adresse {
do
  PARFSX1^hadr := PARF^adr;
end
}
#params2 {
do
  PARFSX^params := PARFSX1^params;
  PARFSX^tdspar := PARFSX1^tdspar;
end
}
#last_adr {
do
  PARFSX^last_adr := PARFSX1^last_adr;
end
}

PARF ->  TYPE ident #params #adresse;
#params {
local
  p : PARAMETRES;
  i : INFOVAR;
  t : TDS;
do
  i := new INFOVAR(TYPE^type, new Emplacement(PARF^hadr, PARF^regLB));
  p := PARF^hparams;
  p.inserer(TYPE^type);
  PARF^params := p;
  t := PARF^htdspar;
  if (t.chercherLocalement(ident^txt) = null) then
    t.inserer(ident^txt, i);
  else
        error(B_02, "nom de parametre deja existant ");   -- write fonction existante
    -- write nom de parametre deja utilise
  end
  PARF^tdspar := t;
end
}
#adresse {
local
  taille : INTEGER;
do
  taille := TYPE^type.getTaille();
  PARF^adr := PARF^hadr - taille;
end
}

-- les types (de base et pointeurs)
TYPE -> STYPE #recapTypePointeur  REFS #creatType ;
#creatType {
do
	TYPE^type := REFS^type;
end
}

#recapTypePointeur {
do
	REFS^htype := STYPE^type;
end
}

REFS -> #syntheseType ;
#syntheseType{
do 
	REFS^type := REFS^htype;
end
}

REFS -> mult #recapType REFS #creatType ;
#recapType{
do
	REFS1^htype := REFS^htype;
end
}
#creatType{
do 
	REFS^type := new POINTEUR(REFS1^type);
end
}

-- types de base
STYPE-> void #creatType ;
#creatType {
do
	STYPE^type := STYPE^tVoid;
end
}

STYPE-> int  #creatType ;
#creatType {
do
	STYPE^type := STYPE^tInt;
end
}

STYPE-> char  #creatType ;
#creatType {
do
	STYPE^type := STYPE^tChar;
end
}

-- corps de methode et bloc d'instructions
BLOC ->  aco #tds #passeTypeRet INSTS acf #isReturn #gen ;
global        
  t : TDS;
#tds {
do
   t :=  new TDS(BLOC^tds);
   INSTS^tds := t;
end
}
#passeTypeRet {
do 
   INSTS^typeRet := BLOC^typeRet;
end 
}
#isReturn {
do
   BLOC^isRet := INSTS^isRet;
end 
}
#gen {
local 
    tailleBloc : INTEGER;
do
   tailleBloc := INSTS^adr - BLOC^hadr;
   write "; tds:\n" + t;
   write "; taille des locales = " + tailleBloc+ "\n";
   -- Le code du bloc est celui de ses instructions
   -- plus le code pour liberer la place occupee
   -- par les variables locales (POP (0) taille)
   BLOC^code := INSTS^code + BLOC^machine.genComment("fin d'un bloc : pop")+ BLOC^machine.genFree(tailleBloc) ;
end
}

-- instructions
INSTS ->  #isReturn #adr #gen;
#adr {
do
  INSTS^adr := INSTS^hadr;
end
}
#isReturn{
do 
   INSTS^isRet := false;
end
}
#gen {
local 
  inst : INFO;
  --ic   : INFO;
do
   --INST^
   -- si c est la fonction init c est a dire d instancialtion d une classe : le retour est implicite du coup je le met ici 	 
   if INSTS^classe /= null then
      inst := INSTS^tds.chercherGlobalement("init");  
      if (inst /= null) then
         match inst with INFOVAR then 
	    write(INSTS^machine.genRetourInstance(INSTS^htailleparams, inst.getEmpl(), INSTS^classe)+"\n");
            INSTS^code := INSTS^machine.genRetourInstance(INSTS^htailleparams, inst.getEmpl(), INSTS^classe); -- je lui passe juste le nombre d arguments : elle se debrouille pour ce reste
            INSTS^isRet := true;  -- *********
         end      
      else     
      -- no code
         INSTS^code := "";
      end 
   else     
      -- no code
      INSTS^code := "";
   end 
end
}

INSTS -> #passeType INST #tds #adresse INSTS #isReturn #adr #gen ;
#passeType {
do
   INST^typeRet := INSTS^typeRet;
   INSTS1^typeRet := INSTS^typeRet;
end 
}
#tds {
do
  INSTS1^tds := INST^stds;
end
}
#adresse {
do
  INSTS1^hadr := INST^adr;
end
}
#isReturn {
do 
  INSTS^isRet := INST^isRet | INSTS1^isRet;
end
}
#adr {
do
  INSTS^adr := INSTS1^adr;
end
}
#gen {
do
    -- append codes
    INSTS^code := INST^code + INSTS1^code;
end
}

-- declaration de variable locale avec ou sans init
INST ->  TYPE ident #tds #adresse #lire_resultat #code_gauche AFFX pv  #verifCompatibilite #isReturn #gen ;
global
  i : INFO;
  adresse : INTEGER;
  empl : Emplacement;
#tds {
local 
   classeEnglobante : INFO;
   c : DTYPE;
   p : DTYPE;
do
  i := INST^tds.chercherLocalement(ident^txt);
  if (i != null) then
        error(B_03, "nom de variable deja utilise ");   -- write fonction existante
    -- write nom de variable deja utilise
  else
     
    classeEnglobante := INST^tds.chercherLocalement("self");
    if (classeEnglobante = null ) then 	 
         classeEnglobante := INST^tds.chercherLocalement("init");
    end 
    if (classeEnglobante /= null) then  -- methode de classe je dois verifier que c est un classe 
       match classeEnglobante with INFOVAR then 
	  p := classeEnglobante.getType();
	  match p with POINTEUR then 
	     c := p.getType();
	     match c with CLASSE then 
	        if c.isAttribut(ident^txt) /= null then
	           error(B_233, " "+ ident^txt + " est un attribut de la classe ");
                else -- ce n est pas un attribut : je le cree 
	           empl := new Emplacement(INST^hadr, INST^regLB);
                   i := new INFOVAR(TYPE^type, empl);
                   INST^tds.inserer(ident^txt, i);
                end
	     end 
          end  
       end 
    else  -- ce n est pas une methode de classe 
       empl := new Emplacement(INST^hadr, INST^regLB);
       i := new INFOVAR(TYPE^type, empl);
       INST^tds.inserer(ident^txt, i);
    end 
  end 
  INST^stds := INST^tds;
end
}
#lire_resultat {
do
  AFFX^lire_resultat := false;
end
}
#adresse {
do
  adresse := INST^hadr + TYPE^type.getTaille();
  INST^adr := adresse;
end
}
#code_gauche {
do
   AFFX^code_gauche := INST^machine.genDeclaration(ident^txt, TYPE^type.getTaille(), empl);
   AFFX^hadresse :=  empl;
   AFFX^hest_adresse := false;
   AFFX^htype := TYPE^type;
end
}
#verifCompatibilite {
local 
   compValue : BOOLEAN;
do 
	if AFFX^type != null then
		compValue := TYPE^type.compareTo(AFFX^type);
		if ~compValue then 
			error(B_04 , "affectation non compatible");
		end 
	end
end  
}
#isReturn{
do 
   INST^isRet := false;
end 
}
#gen {
local
    leCode : STRING;
do
    INST^code := AFFX^code  + INST^machine.genComment("fin de declaration de "+ident^txt);
    -- := AFFX^code + INST^machine.genComment("declaration => pop") + INST^machine.genFree(TYPE^type.getTaille()) + INST^machine.genComment("fin de declaration de "+ident^txt);
end
}

-- instruction expression (affectation et appel de procedure)
INST -> #lire_resultat E pv #adresse #stds #isReturn #gen ;
#gen {
do
    -- consommer la valeur si elle existe
    INST^code :=  E^code;
    -- E^code + INST^machine.genComment("valeur inutile")+INST^machine.genFree(E^type.getTaille());
end
}
#adresse {
do
  INST^adr := INST^hadr;
end
}
#lire_resultat {
do
  E^lire_resultat := false;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#isReturn{ 
do
   INST^isRet := false;
end
}

-- bloc d'instructions
INST ->  #passeTypeRet #tds BLOC #adresse #stds #isReturn #gen ;
#passeTypeRet{
do
   BLOC^typeRet := INST^typeRet;
end
}
#adresse {
do
  INST^adr := INST^hadr;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#tds {
do
  --BLOC^tds := new TDS(INST^tds);
end
}
#isReturn{ 
do
   INST^isRet := false;
end
}
#gen {
do
    INST^code := BLOC^code;
end
}

-- conditionnelle
INST ->   si paro #lire_resultat E parf #tds #passeTypeRet BLOC SIX #adresse #stds #isReturn #gen;
#lire_resultat{
do
  E^lire_resultat := true;
end
}
#passeTypeRet{
do
   BLOC^typeRet := INST^typeRet;
   SIX^typeRet := INST^typeRet;
end 
}
#adresse {
do
  INST^adr := INST^hadr;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#tds {
do
  BLOC^tds := new TDS(INST^tds);
end
}
#isReturn {
do
  INST^isRet := BLOC^isRet & SIX^isRet;
end
}
#gen {
do
    --write "code de la condition : "+ E^code;
    INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code);
end
}

SIX ->    sinon #tds #passeTypeRet BLOC #isReturn #gen;
#tds {
do
  BLOC^tds := new TDS(SIX^tds);
end
}
#passeTypeRet {
do
   BLOC^typeRet := SIX^typeRet;
end
}
#isReturn {
do
   SIX^isRet := BLOC^isRet;
end 
}
#gen {
do
    SIX^code := BLOC^code; 
end
}

SIX -> #isReturn #gen ;
#isReturn {
do
   SIX^isRet := false;
end 
}
#gen {
do
    SIX^code := ""; 
end
}

-- retour de fonction
INST ->  retour #lire_resultat E pv #adresse #tds #verifReturn #isReturn #gen ;
#lire_resultat{
do
  E^lire_resultat := true;
end
}
#adresse {
do 
  INST^adr := INST^hadr;
end
}
#tds {
do
  INST^stds := INST^tds;
end
}
#verifReturn {
do
   if ~INST^typeRet.compareTo(E^type) then 
      error(B_21, "faux retour");
   end 
end 
}
#isReturn {
do
   INST^isRet := true;
end  
}
#gen {
do
  -- sortir de la fonction courante en retournant la valeur de E
  INST^code := INST^machine.genRetour(INST^htailleparams, E^type.getTaille(), E^code); -- + E^code;
end
}

-- inline asm
INST ->  asm   #tds ASM #adresse #stds #isReturn #gen;
#adresse {
do
  INST^adr := INST^hadr;
end
}
#stds {
do
  INST^stds := INST^tds;
end
}
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := INST^tds; 
end
}
#isReturn {
do
   INST^isRet := true; -- ATTENTION: on n'a pas les moyens de verifier
end 
}
#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
   INST^code := INST^machine.genCodeInLine(ASM^code_asm);
end
}

-- les expressions
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
-- ici je demande est ce que j ai besoin de verifier la compatibilite des types 
-- Si AFFX^type est nul alors pas besoin de verifier 
E ->   A  #getType #code_gauche AFFX #verifCompatible #estAffectable #gen ;
global
    typeE : DTYPE;
#getType {
do
    typeE := A^type;
    E^type := typeE;
end
}
#code_gauche {
do
    AFFX^hest_adresse := A^est_adresse;
    AFFX^hadresse := A^adresse;
    AFFX^code_gauche := A^code;
    AFFX^htype := typeE; 
end
}
#verifCompatible {
local 
   compValue : BOOLEAN;
do
	if ~AFFX^vide then
		compValue := A^type.compareTo(AFFX^type);
		if ~compValue then 
			error(B_6 , "affectation : type non compatible");
			-- ecrire erreur de typage d affectation 
		end 
	end
end  
}
-- j affecte a E le type du cote gauche de l affectation 
#estAffectable{
do
   E^affectable := false; -- car l'expr sera brut en sommet de pile : non affectable (pas d'@)
   --if AFFX^vide then
   --    E^affectable := A^affectable;
   --else 
   --    E^affectable := false; 
   --end  
end 
}
#gen {
do
  if AFFX^estAffectation then
    if ~A^affectable then
        error(NonAffectable , "Le cote gauche n est pas affectable");
    end
  end
  -- prendre en compte l'eventuelle affectaion puis
  -- NON (responsabilite delegue a AFFX) :  mettre en sommet de pile la nouvelle valeur de A (code + transmettre adresse, est_adresse ...) 
  E^code := AFFX^code; -- + AFFX^code_adresse_expr + E^machine.genReadIndirectMem(typeE); -- indirect car AFFX ne connait pas le vrai type de E donc pas sa taille : si maintenant
  E^est_adresse := A^est_adresse;
  E^adresse := A^adresse;
end 
}

-- affectation  : laisse en somment de pile la valeur affectee
AFFX -> affect A #getType #estVide #gen ;
-- si lire_resultat alors genere le code pour lire le resultat apres affectation sion null
global
    t : DTYPE;
#getType {
do 
   t := A^type;
   AFFX^type := t;
end 
}
#estVide{
do
  AFFX^vide := false;
end 
}
#gen {
local
    leCode : STRING; -- code de l'affectation
    adr_gauche : STRING;
    empl_gauche : Emplacement;
    empl_droit : Emplacement; 
    code_valeur_gauche : STRING; -- code pour laisser en sommet de pile la nouvelle valeur de la varible affectee
    codedroit : STRING;
do
   -- pour visualiser les codes errones
   leCode :=  AFFX^machine.genComment("adresse d'affectation inexistante 4");
   codedroit :=  AFFX^machine.genComment("adresse terme droit d'affectation inexistante 3");
   AFFX^estAffectation := true;
-- lire la valeur de droite    
   empl_droit := A^adresse;
   if empl_droit /= null then
        -- empl_droit est l'emplacement du terme de droite
	-- if (empl_droit = AFFX^emplNull) then
        codedroit := A^code + AFFX^machine.genReadMem(empl_droit, t.getTaille());
   else
        if A^est_adresse then
            -- lire indirect l'adresse
            codedroit := A^code + AFFX^machine.genReadIndirectMem(t.getTaille());
        else
            -- le terme de droite est une constante ou a un appel de procedure
            codedroit := A^code ;
        end      
   end
-- recuperer l'adresse du terme de gauche
-- affecter
-- laisser en sommet de pile la nouvelle valeur de la variable affectee ssi lire_resultat
   code_valeur_gauche := AFFX^machine.genComment("code de la nouvelle de la variable affectee");
   empl_gauche := AFFX^hadresse;
   if empl_gauche /= null then
     -- empl_gauche est l'adresse du terme gauche
     code_valeur_gauche := code_valeur_gauche + AFFX^machine.genReadMem(empl_gauche, AFFX^htype.getTaille());
     leCode := AFFX^code_gauche + AFFX^machine.genAffectation(codedroit, AFFX^hadresse, t.getTaille());
   else
     if AFFX^hest_adresse then
        code_valeur_gauche := code_valeur_gauche + AFFX^code_gauche + AFFX^machine.genReadIndirectMem(AFFX^htype.getTaille());
        -- ecrire indirect a l'adresse 
        leCode := AFFX^machine.genWriteIndirectMem(AFFX^code_gauche, codedroit, t.getTaille());   
     else
        error(Interne_adresse, "adresse d'affectation inexistante 1");
     end
   end
   if AFFX^lire_resultat then
      AFFX^code := leCode + code_valeur_gauche;
   else
      AFFX^code := leCode;
   end
end
}

AFFX ->  #getType #estVide #gen ;
-- si lire_resultat alors genere le code pour lire le resultat sinon null
#getType {
do 
   AFFX^type := null;
end 
}
#estVide{
do
   AFFX^vide := true;
end 
}
#gen {
local
    leCode : STRING;
    empl_gauche : Emplacement;
    code_valeur_gauche : STRING;
do
    -- pas d'affectation : 
    AFFX^estAffectation := false;
    
    -- recuperer l'adresse du terme de gauche
    -- laisser en sommet de pile la valeur du terme de gauche
    leCode := AFFX^machine.genComment("pas d'affectation : code de l'expression") + AFFX^code_gauche;
    
    empl_gauche := AFFX^hadresse;
    if empl_gauche /= null then
     -- empl_gauche est l'adresse du terme gauche
     code_valeur_gauche := AFFX^machine.genReadMem(empl_gauche, AFFX^htype.getTaille());
    else
        if AFFX^hest_adresse then
            -- il y a l'adresse de l'expression en sommet de pile
            code_valeur_gauche := AFFX^machine.genReadIndirectMem(AFFX^htype.getTaille());   
        else
            -- le code correspond a une constante ou a un appel de procedure : transmettre
            code_valeur_gauche := "";
        end
    end
    if AFFX^lire_resultat then
      AFFX^code := leCode + code_valeur_gauche;
    else
      AFFX^code := leCode;
    end
end
}

-- relation
A ->   R #hcode #hadresse AX  #verifType #getType #estAffectable #adresse #gen;
#hcode {
do
  AX^hcode := R^code;
end
}
#hadresse {
do
  AX^hest_adresse := R^est_adresse;
  AX^hadresse := R^adresse;
end
}
#verifType {
do
   if ~AX^vide then 
	  if ~R^type.isOperable() then 
		error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
	  end
   end 
end 
}
#getType{
do
	if AX^vide then 
		A^type := R^type;
	else 
		A^type := A^tInt;
	end 
   
end 
}
#estAffectable {
do 
	if AX^vide then 
		A^affectable := R^affectable;
	else 
		A^affectable := false;
	end 
end 
}
#adresse {
do
  A^est_adresse := AX^est_adresse;
  A^adresse := AX^adresse;
end
}
#gen {
do
  A^code := AX^code;
end
} 

AX -> OPREL R #verifType #extension #adresse #gen;
#verifType {
do
    if ~R^type.isOperable() then 
        error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
    end
end 
}
#extension {
do
   AX^vide := false; 
end 
}
#adresse {
do
  AX^est_adresse := false;
  AX^adresse := null;
end
}
#gen {
local
   adr_gauche : Emplacement;
   adr_droite : Emplacement;
   codegauche : STRING; -- valeur du terme de gauche
   codedroit : STRING; -- valeur du terme de droite
do
   adr_gauche := AX^hadresse;
   if adr_gauche = null then
        -- hcode contient la valeur du terme gauche
        codegauche := AX^hcode;
   else
        -- hcode ne contient pas encore la valeur du terme gauche
        -- adr_gauche est l'adresse ou se trouve la valeur
        codegauche := AX^hcode + AX^machine.genReadMem(adr_gauche, R^type.getTaille());  
   end
   adr_droite := R^adresse;
   if adr_droite = null then
        -- R^code contient la valeur du terme droit
        codedroit := R^code;
   else
        -- R^code ne contient pas encore la valeur du terme droit
        -- adr_droite est l'adresse ou se trouve la valeur
        codedroit := R^code + AX^machine.genReadMem(adr_droite, R^type.getTaille());  
   end
   AX^code := AX^machine.genOpBinaire(codegauche, OPREL^code, codedroit); 
end
}

AX -> #extension #adresse #gen;
#extension{
do 
   AX^vide := true; 
end 
}
#adresse {
do
  AX^est_adresse := AX^hest_adresse;
  AX^adresse := AX^hadresse;
end
}
#gen {
do
  AX^code := AX^hcode;
end
}

-- operateurs relationnels
OPREL -> inf #gen;
#gen {
do
   OPREL^code := OPREL^machine.genIInferieur();
end
}
OPREL -> sup #gen;
#gen {
do
   OPREL^code := OPREL^machine.genISuperieur();
end
}
OPREL -> infeg #gen;
#gen {
do
   OPREL^code := OPREL^machine.genIInfEgal();
end
}
OPREL -> supeg #gen;
#gen {
do
   OPREL^code := OPREL^machine.genISupEgal();
end
}
OPREL -> eg #gen;
#gen {
do
   OPREL^code := OPREL^machine.genIEgal();
end
}
OPREL -> neg #gen;
#gen {
do
   OPREL^code := OPREL^machine.genIDifferent();
end
}

R ->  T #hcode #hadresse RX #verifType #getType #estAffectable #adresse #gen;
#hcode {
do
   RX^hcode := T^code;
end
}
#hadresse {
do
  RX^hest_adresse := T^est_adresse;
  RX^hadresse := T^adresse;
end
}
#verifType {
do
  if ~RX^vide then 
	if ~T^type.isOperable() then 
		error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
	end
  end 
end 
}
#getType{
do
	if RX^vide then 
		R^type := T^type;
	else 
		R^type := R^tInt;
	end 
   
end 
}
#estAffectable {
do 
	if RX^vide then 
		R^affectable := T^affectable;
	else 
		R^affectable := false;
	end 
end 
}
#adresse {
do
  R^est_adresse := RX^est_adresse;
  R^adresse := RX^adresse;
end
}
#gen {
do
   R^code := RX^code;
end
}

-- additions ...
RX ->   OPADD  T #verifType #hcode #hadresse RX #extension #adresse #gen;
#hcode {
local
   adr_gauche : Emplacement;
   adr_droite : Emplacement;
   codegauche : STRING; -- valeur du terme de gauche
   codedroit : STRING; -- valeur du terme de droite
do
   adr_gauche := RX^hadresse;
   if adr_gauche = null then
        -- hcode contient la valeur du terme gauche
        codegauche := RX^hcode;
   else
        -- hcode ne contient pas encore la valeur du terme gauche
        -- adr_gauche est l'adresse ou se trouve la valeur
        codegauche := RX^hcode + RX^machine.genReadMem(adr_gauche, T^type.getTaille());  
   end
   adr_droite := T^adresse;
   if adr_droite = null then
        -- T^code contient la valeur du terme droit
        codedroit := T^code;
   else
        -- T^code ne contient pas encore la valeur du terme droit
        -- adr_droite est l'adresse ou se trouve la valeur
        codedroit := T^code + RX^machine.genReadMem(adr_droite, T^type.getTaille());  
   end
   RX1^hcode := RX^machine.genOpBinaire(codegauche, OPADD^code, codedroit); 
end
}
#hadresse {
do
  -- on a une valeur en sommet de pile
  RX1^hest_adresse := false;
  RX1^hadresse := null;
end
}
#adresse {
do
  RX^est_adresse := RX1^est_adresse;
  RX^adresse := RX1^adresse;
end
}
#gen {
do
  RX^code := RX1^code;
end
}
#verifType {
do
    if ~T^type.isOperable() then 
        error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
    end
end 
}
#extension {
do 
   RX^vide := false; 
end 
}

RX -> #extension #adresse #gen;
#extension {
do
   RX^vide := true; 
end
}
#adresse {
do
  RX^est_adresse := RX^hest_adresse;
  RX^adresse := RX^hadresse;
end
}
#gen {
do
  RX^code := RX^hcode;
end
}

-- operateurs additifs
OPADD -> plus #gen;
#gen {
do
   OPADD^code := OPADD^machine.genIPlus();
end
}
OPADD -> moins #gen;
#gen {
do
   OPADD^code := OPADD^machine.genIMoins();
end
}
OPADD -> ou #gen;
#gen {
do
   OPADD^code := OPADD^machine.genBOu();
end
}

-- multiplication, ...
T ->  F #hcode #hadresse TX   #verifType #getType #estAffectable #adresse #gen ;
#hcode {
do
   TX^hcode := F^code;
end
}
#hadresse {
do
  TX^hest_adresse := F^est_adresse;
  TX^hadresse := F^adresse;
end
}
#verifType {
do
  if ~ TX^vide then 
	if ~F^type.isOperable() then 
		error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
	end
 end 
end 
}
#getType{
do
   if TX^vide then 
		T^type := F^type;
	else 
		T^type := T^tInt;
	end 
end 
}
#estAffectable {
do 
	if TX^vide then 
		T^affectable := F^affectable;
	else 
        -- on a une valeur (en l'occurence un entier) en sommet de pile 
		T^affectable := false;
	end 
end 
}
#adresse {
do
  T^est_adresse := TX^est_adresse;
  T^adresse := TX^adresse;
end
}
#gen {
do 
    T^code := TX^code;
end
}

TX ->  OPMUL  F #verifType #hcode #hadresse TX #extension #adresse #gen;
#verifType {
do
    if ~F^type.isOperable() then 
        error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
    end
end 
}
#hcode {
local
   adr_gauche : Emplacement;
   adr_droite : Emplacement;
   codegauche : STRING; -- valeur du terme de gauche
   codedroit : STRING; -- valeur du terme de droite
do
   adr_gauche := TX^hadresse;
   if adr_gauche = null then
        -- hcode contient la valeur du terme gauche
        codegauche := TX^hcode;
   else
        -- hcode ne contient pas encore la valeur du terme gauche
        -- adr_gauche est l'adresse ou se trouve la valeur
        codegauche := TX^hcode + TX^machine.genReadMem(adr_gauche, F^type.getTaille());  
   end
   adr_droite := F^adresse;
   if adr_droite = null then
        -- F^code contient la valeur du terme droit
        codedroit := F^code;
   else
        -- F^code ne contient pas encore la valeur du terme droit
        -- adr_droite est l'adresse ou se trouve la valeur
        codedroit := F^code + TX^machine.genReadMem(adr_droite, F^type.getTaille());  
   end
   TX1^hcode := TX^machine.genOpBinaire(codegauche, OPMUL^code, codedroit); 
end
}
#hadresse {
do
  -- on a une valeur en sommet de pile
  TX1^hest_adresse := false;
  TX1^hadresse := null;
end
}
#extension {
do
  TX^vide := false;
end 
}
#adresse {
do
  TX^est_adresse := TX1^est_adresse;
  TX^adresse := TX1^adresse;
end
}
#gen {
do
   TX^code := TX1^code;
end
}

TX -> #extension #adresse #gen ;
#extension {
do
  TX^vide := true;
end 
}
#adresse {
do
  TX^est_adresse := TX^hest_adresse;
  TX^adresse := TX^hadresse;
end
}
#gen {
do
  TX^code := TX^hcode;
end
}

-- operateurs multiplicatifs
OPMUL -> mult #gen;
#gen {
do
   OPMUL^code := OPMUL^machine.genIMultiplication();
end
}

OPMUL -> div #gen;
#gen {
do
   OPMUL^code := OPMUL^machine.genIDivision();
end
}
OPMUL -> mod #gen;
#gen {
do
   OPMUL^code := OPMUL^machine.genIModulo();
end
}
OPMUL -> et  #gen;
#gen {
do
   OPMUL^code := OPMUL^machine.genIEt();
end
}

-- expressions de base
-- Constante entiere
F -> entier  #getType #estAffectable #gen;
#getType {
do
   F^type := F^tInt;
end 
}
#estAffectable{
do 
   F^affectable := false;
end 
}
#gen {
do
  F^code := F^machine.genEntier(entier^txt);
  F^est_adresse := false;
  F^adresse := null;
end
}

-- Constante chaine : non traite
--F -> chaine  #getType #estAffectable #gen ;
--#getType {
--do 
--   F^type := F^tString;--new POINTEUR(F^tChar);
--end 
--}
--#estAffectable{
--do 
--   F^affectable := false;
--end 
--}
--#gen {
--do
--  F^code := F^machine.genString(chaine^txt);
--F^est_adresse := ?
--F^adresse := ?
--end
--}


-- Constante caractere
F -> caractere  #getType #estAffectable #gen ;
#getType {
do 
   F^type := F^tChar;
end 
}
#estAffectable{
do 
   F^affectable := false;
end 
}
#gen {
do
  F^code := F^machine.genCaractere(caractere^txt);
  F^est_adresse := false;
  F^adresse := null;
end
}

-- expression unaire
F ->  OPUN  F  #verifType #getType #estAffectable #adresse #gen;
#verifType {
do
    if ~F1^type.isOperable() then 
        error(B_20, "Les operations ne peuvent etre faites que sur les entiers");
    end
end 
}
#getType{
do
   F^type := F1^type;
end 
}
#estAffectable{
do 
   F^affectable := false;
end 
}
#adresse {
do
  F^est_adresse := F1^est_adresse;
  F^adresse := null;
end
}
#gen {
local
    adr_droite : Emplacement;
    codedroit : STRING;
do
   adr_droite := F1^adresse;
   if adr_droite = null then
        -- F1^code contient la valeur du terme droit
        codedroit := F1^code;
   else
        -- F^code ne contient pas encore la valeur du terme droit
        -- adr_droite est l'adresse ou se trouve la valeur
        codedroit := F1^code + F^machine.genReadMem(adr_droite, F1^type.getTaille());  
   end 
  if OPUN^code = "" then
    F^code := codedroit;
  else
    F^code := F^machine.genOpUnaire(OPUN^code, codedroit);
  end
end
}

-- operateurs unaires
OPUN -> plus  #gen;
#gen {
do
   OPUN^code := ""; -- ignorer
end
}
OPUN -> moins  #gen;
#gen {
do
   OPUN^code := OPUN^machine.genINegation();
end
}
OPUN -> non #gen;
#gen {
do
   OPUN^code := OPUN^machine.genBNegation();
end
}

-- pointeur NULL
F -> null  #getType #estAffectable #gen ;
#getType {
do 
   F^type := F^tPointeurNull;
end
}
#estAffectable{
do 
   F^affectable := false;
end 
} 
#gen {
do
  F^code := F^machine.genComment("pointeur null") + F^machine.genPushAdresse(F^emplNull);
  F^est_adresse := true;
  F^adresse := null;
end
}
 
-- expression parenthesee
F ->  paro #lire_resultat E parf #getType #estAffectable #adresse #gen;
#lire_resultat { -- ??? pas sur
do
   E^lire_resultat := false;
end
}
#getType {
do 
   F^type := E^type;
end 
}
#estAffectable{
do 
   F^affectable := E^affectable;
end 
}
#adresse {
do
  F^est_adresse := E^est_adresse;
  F^adresse := E^adresse;
end
}
#gen {
do
  F^code := E^code;
end
}


F ->  paro TYPE parf  F #verifCast #getType #estAffectable #gen;
    -- cast est ce que c est castable et puis effectue le cast 
#verifCast{
do
   if ~ F1^type.castableTo(TYPE^type) then 
            error(B_13 , "Impossible de caster");
      -- ecrire ne peut pas etre caster 
   end 
end
}
#getType{
do
   F^type := TYPE^type;
end 
}
#estAffectable{
do 
   F^affectable := F1^affectable;
end 
}
#gen {
do
  F^code := F^machine.genComment("cast en "+TYPE^type.getNom()+"de -- ") + F1^code + F^machine.genComment("-- : valeur castee");
  F^est_adresse := F1^est_adresse;
  F^adresse := F1^adresse; 
end
}

-- appel de sous-programme
F ->  ident  paro #params ARGS parf #gen #getType #estAffectable ;
-- on verifie ici la declaration de la fonction et on recupere le infofonction
global   
  i : INFOFONCTION;
#params {
do
  ARGS^hparams := new PARAMETRES();
end
}
#gen {
local
  in : INFO;
  p : PARAMETRES; 
do
  in := F^tds_fonction.chercherLocalement(ident^txt);
  if (in = null) then
    error(B_14 , "la fonction appelee n existe pas ");
  else
    match in with INFOFONCTION then
        i := in;
    else
        error(B_17 , " c est pas une fonction");
    end
    p := i.getParametres();
    if (! p.compareTo(ARGS^params)) then
      error(B_15 , " parametres d'appel erronés");
    else
      F^code := F^machine.genComment("empilement des parametres")+ARGS^code + F^machine.genCall(ident^txt);
      F^est_adresse := false;
      F^adresse := null;
    end
  end
end
}
#getType {
do 
   F^type := i.getRetour();
end 
}
#estAffectable{
do
   F^affectable := false;
end
}

-- acces variable
F ->  ident #gen #getType #estAffectable ;
global 
   type : DTYPE;
#gen {
local 
  t          	   : TDS;
  iTemp            : INFO;
  classeEnglobante : INFO;
  p                : DTYPE;
  c                : DTYPE;
  champAttribut    : CHAMP;
do 
  t := F^tds;
  iTemp := t.chercherGlobalement(ident^txt);
  if (iTemp = null) then
    	-- je verifie si c est un attribut 
      classeEnglobante := F^tds.chercherLocalement("self");
      if (classeEnglobante = null ) then 	 
         classeEnglobante := F^tds.chercherLocalement("init");
      end 
      if (classeEnglobante /= null) then                        
         match classeEnglobante with INFOVAR then
	    p := classeEnglobante.getType();
	    match p with POINTEUR then 
	       c := p.getType();
	       match c with CLASSE then 
	          champAttribut := c.isAttribut(ident^txt); 
                  if champAttribut = null then
     	             error(B_16 , "la variable n existe pas :"+ident^txt); 
                  else -- c est un attribut  
	             type := champAttribut.getType();
	             -- recuperation de l adresse du champs 
                     F^code := F^machine.genComment("acces a l attribut  "+ident^txt)
                             + F^machine.genLire("", 1, classeEnglobante.getEmpl())   -- a revoir la taille de la variable avec leger  
                             + F^machine.genAdrField(champAttribut.getDep()); -- to call the function depending on his number (deplacement)
                     F^adresse := null; -- prb
                     F^est_adresse := true;  -- prb
                     --F^var := null;   -- a revoir 
                     --F^initialiser := true;  -- a revoir
      	             -- a completer c1 
                  end
	       end  
            end 
         end 
      end 
  else
     match iTemp with INFOVAR then
        type := iTemp.getType();
        F^code := F^machine.genComment("acces a "+ident^txt);--genLire(ident^txt, type.getTaille(), i.getEmpl());
        F^adresse := iTemp.getEmpl();
        F^est_adresse := false;
        ---F^var := iTemp;
        --F^initialiser := iTemp.getInitialiser();
    else
        error(B_17 , " c est pas une variable ca");
    end

  end
end 
}

#getType {
do
   F^type := type;
end 
}
#estAffectable{
do 
   F^affectable := true;
end 
}

---- acces zone pointee
F -> mult F #getType #estAffectable #adresse;
#getType{
do 
    match F1^type with POINTEUR then
        F^type := F1^type.getType();
    else
        error(B_18 , " c est pas un pointeur");
    end 
end
}
#estAffectable{
do 
   F^affectable := true;
end 
}
#adresse {
local
  adr_du_pointeur : Emplacement;
  leCode : STRING;
do
    -- pour visualiser les codes errones
    leCode :=  F^machine.genComment("adresse d'affectation inexistante 6");
    adr_du_pointeur := F1^adresse;
    if ~F1^est_adresse  then
        if adr_du_pointeur /= null then
            -- adresse du pointeur connue
             leCode := F1^code + F^machine.genReadMem(adr_du_pointeur, F1^type.getTaille());
            -- verifier que le code est # de 0[SB]
        else
            error(Interne_adresse, "adresse d'affectation inexistante 5");
        end
    else
        leCode := F1^code + F^machine.genReadIndirectMem(F1^type.getTaille());
    end
    -- verifier que le code est # de 0[SB]    
    F^code := F^machine.genVerificationPointeur(leCode, F^emplNull) ;
    F^est_adresse := true; -- le code laisse en sommet de pile est une adresse
    F^adresse := null; -- adresse inconnue 
end
}

-- arguments appel de sous-programme
ARGS -> #params #gen;
#params {
do
  ARGS^params := ARGS^hparams;
end
}
#gen {
do
  ARGS^code := "";
end
}
 
ARGS -> #lire_resultat E #params1 ARGSX #params2 #gen;
#lire_resultat { 
do
   E^lire_resultat := true;
end
}
#params1 {
local
   par : PARAMETRES;
do
  par := ARGS^hparams;
  par.inserer(E^type);
  ARGSX^hparams := par;
end
}
#params2 {
do
  ARGS^params := ARGSX^params;
end
}
#gen {
do
  ARGS^code := ARGS^machine.genComment("empilement des parametres") + ARGSX^code + ARGS^machine.genComment("parametre de sous-programme")+ E^code + ARGS^machine.genComment("charger le parametre ?");
end
}

ARGSX ->  #params #gen;
#params {
do
  ARGSX^params := ARGSX^hparams;
end
}
#gen {
do
  ARGSX^code := "";
end
}

ARGSX -> virg #lire_resultat E #params1 ARGSX #params2 #gen;
#lire_resultat{
do
  E^lire_resultat := true;
end
}
#params1 {
local
    par : PARAMETRES; 
do
  par := ARGSX^hparams;
  par.inserer(E^type);
  ARGSX1^hparams := par;
end
}
#params2 {
do
  ARGSX^params := ARGSX1^params;
end
}
#gen { 
do
  ARGSX^code := ARGSX1^code + ARGSX^machine.genComment("parametre de sous-programme")+E^code + ARGSX^machine.genComment("charger le parametre ?");
  -- ARGSX^code := ARGSX^machine.genComment("parametre de sous-programme")+E^code + ARGSX^machine.genComment("charger le parametre ?") + ARGSX1^code; 
end
}


--====decommenter pour ============ MOC extension =================
ENTITES -> #htds_classe IMPLEMENTATION #tds_classe ENTITES #tds_fonction #gen ;
#gen  {
do 
  ENTITES^code := IMPLEMENTATION^code + ENTITES1^code;
end
}
#tds_fonction {
do
  ENTITES^stds_fonction := ENTITES1^stds_fonction;
end
}
#htds_classe {
do
  IMPLEMENTATION^tds_classe := ENTITES^tds_classe;
end
}
#tds_classe {
do
  if ( IMPLEMENTATION^stds_classe = null) then
    error(Warning, "IMPLEMENTATION^stds_classe dans ENTITES-> ... est null" );
  end
  ENTITES1^tds_classe := IMPLEMENTATION^stds_classe;
end
}

--definition d'une classe
IMPLEMENTATION ->  classe identc #hclasse_fille SUPER aco #hattributs ATTRIBUTS acf #tds_classe METHODES #stds_classe #genTV fin #aff;
global
    classe : CLASSE;
#aff {
do
  write "\n";
  write "\n";
  write "Table des classes visibles par : " + identc^txt +" : ";
  write "\n";
  write IMPLEMENTATION^tds_classe;
end
}
#hclasse_fille {
do
  SUPER^hclasse_fille := identc^txt;
end
}
#hattributs {
local
    lc : LCHAMPS;
    c : CHAMP;
    tc : DTYPE;
do
  lc := SUPER^attributs;
  -- le champ tv existe deja par heritage de la classe mere
  ATTRIBUTS^hattributs := SUPER^attributs;
  c := lc.get(lc.size());
  tc := c.getType();
  ATTRIBUTS^hdep := c.getDep() + tc.getTaille();
end
}
#tds_classe {
local
    nom_classe : String;
    i : INFO;
    iclasse : INFOCLASSE;
    iclasse_mere : INFOCLASSE;
    classe_mere : CLASSE;
    att : LCHAMPS;
    tdsC : TDS;
do
    tdsC := null;
    nom_classe := identc^txt;
    if (IMPLEMENTATION^tds_classe = null) then
      error(Warning, IMPLEMENTATION^tds_classe+" est null");
    end
    i := IMPLEMENTATION^tds_classe.chercherLocalement(nom_classe);
    if (i /= null) then
          error(Class_exist, nom_classe);
    else
          att := ATTRIBUTS^attributs;
          classe := new CLASSE(nom_classe, att, SUPER^classe_mere);
          iclasse := new INFOCLASSE(classe, SUPER^iclasse_mere);
          tdsC := IMPLEMENTATION^tds_classe;
          tdsC.inserer(nom_classe, iclasse);
          if ( tdsC = null) then
            error(Warning, "tdsC dans IMPLEMENTATIONS -> ... ; est null" );
          end
          METHODES^tds_classe := tdsC;
          METHODES^classe := nom_classe;
    end
end
}
#stds_classe {
do
    if ( METHODES^stds_classe = null) then
	error(Warning, "METHODES^stds_classe dans IMPLEMENTATIONS-> ... est null" );
    else 
	IMPLEMENTATION^stds_classe := METHODES^stds_classe;
   end
end
}
#genTV{
local 
 ic    : INFO;
 tdsM  : TDS;
 genTv : String;
do
   ic := METHODES^stds_classe.chercherLocalement(identc^txt);
   genTv := "";
   match ic with INFOCLASSE then
      -- primo je genere le code pour la struct avec l etiquete
       tdsM := ic.listeMethodes();
       genTv := IMPLEMENTATION^machine.genTv(identc^txt, tdsM);
      -- je recupere l etiquette  
       ic.setTv("_"+identc^txt + "_methode");
	-- j initialise tv
   end 
   IMPLEMENTATION^code := METHODES^code + genTv;
end 
}

-- surclasse
SUPER -> #attributs_herites #classe;
#attributs_herites {
local
    -- nsobject : CLASSE;
    tv : CHAMP;
    attributs : LCHAMPS;
do
  if (~SUPER^hclasse_fille.equals("NSObject")) then
    error(MultipleOrphanClasses, SUPER^hclasse_fille + "doit au moins heriter de NSObject");
  else 
    -- creation de NSObject
    -- inserer d'abord le champ qui contiendra l'Emplacement du code des methodes du type reel des instances 
    -- recuperer tv et le mettre en unique champ de la classe
    attributs := new LCHAMPS();
    tv := new CHAMP("tv", new POINTEUR(null), 1);
    attributs.inserer(tv);
    SUPER^attributs := attributs;
   end 
end
}
#classe {
do
    SUPER^classe_mere := null; 
    SUPER^iclasse_mere := null;
end
}


SUPER -> dpts identc #classe_attributs_herites;
#classe_attributs_herites {
local
    i : INFO;
    iclasse : INFOCLASSE;
    t : DTYPE;
    classe : CLASSE;
    
do
  if (SUPER^hclasse_fille.equals("NSObject")) then
    error(OneRootClass, SUPER^hclasse_fille + "n'a pas de classe parente : c'est la racine");
  else  
    i := SUPER^tds_classe.chercherLocalement(identc^txt);
    if (i = null) then
            error(UnknownClass, identc^txt);
    else
        match i with INFOCLASSE then
            iclasse := i;
            t := iclasse.getType();
            match t with CLASSE then
                classe := t;
                SUPER^classe_mere := classe; 
                SUPER^iclasse_mere := iclasse;
                -- recuperer les attributs herites
                SUPER^attributs := classe.getAttributs();
            else
                error(InterneInfoclasse, "INFOCLASSE.getType()doit retourner une CLASSE");
            end
        else
            error(InterneTDSClasse, "tds_classe ne doit contenir que des INFOCLASSE");
        end
    end
  end
end
}

--attributs
ATTRIBUTS -> #attributs ;
#attributs {
do
    ATTRIBUTS^attributs := ATTRIBUTS^hattributs; 
end
}

ATTRIBUTS -> TYPE ident pv #attributs1 ATTRIBUTS #attributs2;
#attributs1 {
local
    lc : LCHAMPS;
    c : CHAMP;
do
    lc := ATTRIBUTS^hattributs;
    c := lc.chercher(ident^txt);
    if (c /= null) then
        error(Att_exist, ident^txt);
    else
        c := new CHAMP(ident^txt, TYPE^type, ATTRIBUTS^hdep);
        lc.inserer(c);
        ATTRIBUTS1^hattributs := lc;
    end
    ATTRIBUTS1^hdep := ATTRIBUTS^hdep + TYPE^type.getTaille();
end
}
#attributs2 {
do
    ATTRIBUTS^attributs := ATTRIBUTS1^attributs; 
end
}

-- methodes
METHODES -> #stds_classe #gen ;
#stds_classe {
do
    METHODES^stds_classe := METHODES^tds_classe;
end
}
#gen {
do
   METHODES^code := "";
end
}

METHODES ->  #init METHODE #tds_classe  METHODES #stds_classe #gen ;

#init {
do
    METHODE^tds_classe := METHODES^tds_classe;
end
}
#tds_classe {
do
    METHODES1^tds_classe := METHODE^stds_classe;
end
}
#stds_classe {
do
    METHODES^stds_classe := METHODES1^stds_classe;
end
} 
#gen {
do
   METHODES^code := METHODE^code + METHODES1^code ;
end
}

METHODE ->  QUAL PTYPE #params #adresse MPARFS #tds #tds_classe  #typeRet #passeTailleparams  BLOC #gen  ;
global
    tailleparams : INTEGER;
    ic : INFOCLASSE;

#passeTailleparams{
do
  tailleparams := -MPARFS^last_adr -1;
  BLOC^htailleparams := tailleparams;
end
}

#typeRet  {
do
  BLOC^typeRet := PTYPE^type;
end
}
#params {
local
    i : INFO;
    
do
    MPARFS^hparams := new PARAMETRES();
    MPARFS^htdspar := new TDS(METHODE^tds);
    i := METHODE^tds_classe.chercherLocalement(METHODE^classe);
    if (!QUAL^qual) then  ----************
        i := new INFOVAR(new POINTEUR(i.getType()), new Emplacement((-1), METHODE^regLB ));
        MPARFS^htdspar.inserer("self", i);
    end
    MPARFS^typeClasse := i.getType();
end
}
#adresse {
local
    n : Integer;
do
    if (!QUAL^qual) then   ---*********
        n := -2;                 -- initialisation des adresses parametre
    else
        n := -1;
    end
    MPARFS^hadr := n;
    BLOC^hadr := 3;               -- initialisation des adresse de bloc
end
}
#tds {
do
    BLOC^tds := MPARFS^tdspar;
end
}
#tds_classe {
local
    i : INFO;
    im : INFOMETHODE;
    tdsC : TDS;
do
    tdsC := METHODE^tds_classe;
    -- inserer la nouvellemethode dans l'infoclasse correspondante
    im := new INFOMETHODE(PTYPE^type, MPARFS^params, QUAL^qual, 0, METHODE^classe);
    i := tdsC.chercherLocalement(METHODE^classe);
    if ( tdsC = null) then
            error(Warning, "tdsC1 dans METHODES -> QUAL ... ; est null" );
    end
    match i with INFOCLASSE then 
        ic := i;
        ic.inserer(MPARFS^nom, im);
        -- maj de tdsC
        tdsC.inserer(METHODE^classe, ic);
        if ( tdsC = null) then
            error(Warning, "tdsC2 dans METHODES -> QUAL ... ; est null" );
        else
            write "\n";
            write tdsC;
            write "fin";
            write "\n";
        end
        BLOC^tds_classe := tdsC;
        METHODE^stds_classe := tdsC;
    else 
        error(InterneTDSClasse, "tds_classe ne doit contenir que des INFOCLASSE");
    end 
end
}
#gen {
local 
    tRetour : DTYPE;
    leCode  : STRING;
do
  leCode := METHODE^machine.genFonction(METHODE^classe +"_" + MPARFS^nom , BLOC^code);
  tRetour := PTYPE^type;
  if(tRetour.isVoid()) then
    -- depiler les arguments
    leCode :=  leCode + METHODE^machine.genRetour(tailleparams, 0, "");  
  end
  write("je sors du if\n");
  write ("\n ********** "+leCode +"\n");
  METHODE^code := leCode; 
end
}

--qualificateur attribut ou methode :  + = de classe, - = d'instance
QUAL -> plus #qual;
#qual {
do
    QUAL^qual := true;
end
}

QUAL -> moins #qual;
#qual {
do
    QUAL^qual := false;
end
}

--type classe 
STYPE-> identc #type;
#type {
local
  in : INFO;
  i : INFOCLASSE;
do
  in := STYPE^tds_classe.chercherLocalement(identc^txt);
  if (in = null) then
    error(UnknownClass , "Classe "+identc^txt+" inconnue");
  else
    match in with INFOCLASSE then
        i := in;
        STYPE^type := i.getType();
    else
        error(InterneInfoClasse, identc^txt+" n'a pas d'infoclasse");
    end
  end
end 
}

-- type BOOL
STYPE-> bool  #type;
#type {
do
  STYPE^type := STYPE^tBool;
end
}

-- type "any"
TYPE -> id  #type;
#type {
do
  TYPE^type := new DTYPE("id", 1);
end
}

-- type argument (ou retour) de methode entre parentheses
PTYPE -> paro TYPE parf #type;
#type {
do
  PTYPE^type := TYPE^type;
end
}

-- parametres de methodes
MPARFS -> #parametres #last_adr ;
#last_adr {
do
  MPARFS^last_adr := MPARFS^hadr;
end
}
#parametres {
do
    MPARFS^params := MPARFS^hparams;
    MPARFS^tdspar := MPARFS^htdspar;
    MPARFS^nom := "";
end
}

MPARFS ->  MPARF #parametres1 MPARFS #parametres2 #last_adr ;
#last_adr {
do
  MPARFS^last_adr := MPARFS1^last_adr;
end
}

#parametres1 {
do
    MPARFS1^hparams := MPARF^params;
    MPARFS1^htdspar := MPARF^tdspar;
    MPARFS1^hadr := MPARF^adr;
end
}
#parametres2 {
do
    MPARFS^params := MPARFS1^params;
    MPARFS^tdspar := MPARFS1^tdspar;
    MPARFS^nom := MPARF^nom + MPARFS1^nom;
end
}

-- selecteur sans parametre
MPARF ->  ident  #parametres #adresse #verifMethodeInit ;
#parametres {
do
    MPARF^nom := ident^txt;
    MPARF^params := MPARF^hparams;
end
}
#adresse {
do
   if (ident^txt.equals("init")) then
      MPARF^adr := MPARF^hadr - 1;
   else
      MPARF^adr := MPARF^hadr;
   end 
end
}

#verifMethodeInit{
local
  p : PARAMETRES;
  i : INFOVAR;
  t : TDS;
  point : POINTEUR;
do
   
   if (ident^txt.equals("init")) then
	   point :=  new POINTEUR(MPARF^typeClasse);   
           i := new INFOVAR (point, new Emplacement((-1), MPARF^regLB ));
           t := MPARF^htdspar;
           if (t.chercherLocalement("init") = null) then
              t.inserer("init", i);
           else
              error(param_exists, "init");
           end
           MPARF^tdspar := t;
   else 
      MPARF^tdspar := MPARF^htdspar;
   end 
end
}



-- selecteur  + type parametre + nom parametre
MPARF ->   ident dpts  PTYPE ident #parametres #adresse;
#parametres {
local
    p : PARAMETRES;
    i : INFOVAR;
    t : TDS;
do
    i := new INFOVAR(PTYPE^type, new Emplacement(MPARF^hadr, MPARF^regLB ));
    p := MPARF^hparams;
    p.inserer(PTYPE^type);
    MPARF^params := p;
    t := MPARF^htdspar;
    if (t.chercherLocalement(ident1^txt) = null) then
        t.inserer(ident1^txt, i);
    else
        error(param_exists, ident1^txt);
    end
    MPARF^tdspar := t;
    MPARF^nom := ident^txt + ":";
end
}
#adresse {
local
  taille : INTEGER;
do
  taille := PTYPE^type.getTaille();
  MPARF^adr := MPARF^hadr - taille;
end
}

-- object nil
F -> nil  #getType #estAffectable #gen  ;
#getType {
do 
   F^type := F^tNil;
end
}
#estAffectable{
do 
   F^affectable := false;
end 
} 
#gen {
do
  F^code := F^machine.genComment("objet nil") + F^machine.genPushAdresse(F^emplNull);
  F^est_adresse := true;
  F^adresse := null;
end
}

--Constante 'YES'
F -> yes  #type #gen  ;
#gen {
do
  F^code := F^machine.genBoolean(true);
  F^est_adresse := false;
  F^adresse := null;
end
}

#type {
do
  F^type := F^tBool;
  F^affectable := false;
end
}

-- Constante 'NO'
F -> no  #type #gen;
#gen {
do
  F^code := F^machine.genBoolean(false);
  F^est_adresse := false;
  F^adresse := null;
end
}
#type {
do
  F^type := F^tBool;
  F^affectable := false;
end
}

-- chaine MOC (commence par @)
F -> chaineo #type #aSupprimer;
#aSupprimer {
do
  F^code := F^machine.genComment(chaineo^txt);
  F^est_adresse := false;
  F^adresse := null;
end
}
#type {
do
  F^type := null; -- pas de type
  F^affectable := false;
end
}

--self = this de Java
F -> self #type #gen ;
#gen {
local
  t  : TDS;
  i  : INFO; 
do
  t := F^tds;
  i := t.chercherGlobalement("self");
  match i with INFOVAR then 
     if (i = null) then
        error(B_16 , " vous n etes pas dans une instance");
     else
        match i with INFOVAR then
           F^code := F^machine.genComment("acces a self");
           F^adresse := i.getEmpl();
           F^est_adresse := false;
        else
           error(B_17 , " c est pas une variable ca");
        end
     end
  end
end
}
#type {
local
  in : INFO;
  i : INFOVAR;
do
  F^affectable := false;
  in := F^tds.chercherGlobalement("self");
  if (in = null) then
    error(IllegalSelf,  "utilisation illegale de self : hors d'une methode");
  else
    match in with INFOVAR then
        i := in;
        F^type := i.getType();
    else
        error(ErreurInterneTDS_self,  "self devrait etre dans la TDS de la methode en tant que variable!");
    end
  end
end 
}

F -> super #type  #gen  ;
#gen {
local
  t : TDS;
  i : INFO;
do
  t := F^tds;
  i := t.chercherGlobalement("super");
  match i with INFOVAR then 
     if (i = null) then
        error(B_16 , " vous n etes pas dans une instance");
     else
        match i with INFOVAR then
           F^code := F^machine.genComment("acces a self");
           F^adresse := i.getEmpl();
           F^est_adresse := false;
        else
           error(B_17 , " c est pas une variable ca");
        end
     end
  end
end
}

#type { -- type pointeur sur la classe mere
local
  in : INFO;
  i : INFOVAR;
  t2 : DTYPE;
  type_self : POINTEUR;
  t : DTYPE;
  classe_self : CLASSE;
do
  F^affectable := false;
  in := F^tds.chercherGlobalement("self");
  if (in = null) then
    error(IllegalSuper,  "utilisation illegale de super : hors d'une methode (d'instance ?)");
  else
    match in with INFOVAR then
        i := in;
        t := i.getType();
        match t with POINTEUR then
            type_self := t;
            t2 := type_self.getType();
            match t2 with CLASSE then
                classe_self := t2;
                F^type := new POINTEUR(classe_self.getClasseMere());
            end
        else
             error(ErreurInterneTDS_self,  "self devrait etre de type POINTEUR");
        end
    else
        error(ErreurInterneTDS_self,  "self devrait etre dans la TDS de la methode en tant que variable!");
    end
  end
end 
}

-- Appel de methode
F -> cro F #params MARGS crf #bonappel_type_initCorrect #gen ;
global
    ic : INFOCLASSE;
    im : INFOMETHODE;
#params {
do
    MARGS^hparams := new PARAMETRES();
end
}
#bonappel_type_initCorrect {
local
    t : DTYPE;
    t2 : DTYPE;
    p : POINTEUR;
    c : CLASSE;
    i : INFO;
    i2 : INFO;
    tds : TDS;
    params : PARAMETRES;
    ic_type : INFOCLASSE;
do--
    im := null; -- initialisation forcee 
    t := F1^type;
    match t with POINTEUR then -- on vérifie que l'instance est bien un pointeur ----
        p := t;
        t2 := p.getType();
	    match t2 with CLASSE then  -- on vérifie que l'instance est bien un pointeur sur un struct
	        c := t2;
            	i := F^tds_classe.chercherLocalement(c.getNomClasse()); -- on recupere l'infoclasse
	        if (i = null) then --
	            error(classe_inexistante, c.getNomClasse());
	        else ---
	            match i with INFOCLASSE then ---
	                ic := i;
	                tds := ic.getMethodes();
	                i2 := tds.chercherGlobalement(MARGS^nom); -- in recupere l'infomethode
	                if (i2 = null) then --
	                    error(methode_inexistante, c.getNomClasse(), MARGS^nom);
	                else --
	                    match i2 with INFOMETHODE then --
	                        im := i2;
	                        --== type de retour
	                        ----== initCorrect : s'assurer que le resultat de l'init est affecte une instance de type compatible
		    		if (MARGS^nom.equals("init")) then
				  match i with INFOCLASSE then
					ic_type := i;					
					F^type := new POINTEUR(ic_type.getType());
				  else
					error(Warning, c.getNomClasse()+" n'a pas d'INFOCLASSE");
				  end
		    		else
				  F^type := im.getRetour();
		    		end
		    		----=/= initCorrect
	                        F^affectable := false;
	                        --=/= type de retour
	                        params := im.getParametres();
	                        if (im.isClassMethod()) then
	                            error(pas_methode_instance, c.getNomClasse(), MARGS^nom);
	                        end
	                        if (!params.compareTo(MARGS^params)) then -- on vérifie les parametres
	                            error(mauvais_parametres, c.getNomClasse(), MARGS^nom);
	                        end
	                    else---
	                        error(pas_methode, "ceci n'est pas une methode");
	                    end ---
	                end  ---
	            else ---
	                error(pas_classe, "ceci n'est pas une classe");
                    end ---
            	end ---
	    else ---
	        error(pas_instance, "ceci n'est pas une instance de classe");
	    end --
    else ----
        error(pas_pointeur, "ceci n'est pas un pointeur");
    end ---
end--
}
#gen {
local 
  tComment : String;
do
   tComment := F^machine.genComment("je passe par laaaaa");
   F^code := tComment + MARGS^code
                + F^machine.genLire("", F1^type.getTaille(), F1^adresse)            -- to modify the self of the fonction and give it the current instance 
                --+ F^machine.genCallMethod(MARGS^nom, ic.getTv() ,im.getNumero()); -- to call the function depending on his number (deplacement)
                + F^machine.genCallMethod(MARGS^nom, F1^adresse ,im.getNumero()); -- to call the function depending on his number (deplacement)
   F^est_adresse := false;
   F^adresse := null;
end
}

-- pour appel methode de classe
F -> cro identc #params MARGS crf #bonappel_type #gen  ;
global
    ic : INFOCLASSE;
    im : INFOMETHODE;

#params {
do
    MARGS^hparams := new PARAMETRES();
end
}
#bonappel_type {
local
    t : DTYPE;
    p : POINTEUR;
    i : INFO;
    i2 : INFO;
    tds : TDS;
    params : PARAMETRES;
do
    i := F^tds_classe.chercherLocalement(identc^txt); -- on recupere l'infoclasse
    if (i = null) then
        error(classe_inexistante, identc^txt);
    else
        match i with INFOCLASSE then
            ic := i; 
            tds := ic.getMethodes();
            i2 := tds.chercherGlobalement(MARGS^nom); -- in recupere l'infomethode
            if (i2 = null) then
                error(methode_inexistante, identc^txt, MARGS^nom);
            else
                match i2 with INFOMETHODE then
                    im := i2;
                    --== type de retour
                    F^type := im.getRetour();
                    F^affectable := false;
                    --=/= type de retour
                    params := im.getParametres();
                    if (!im.isClassMethod()) then
                        error(pas_methode_classe, identc^txt, MARGS^nom);
                    end
                    if (!params.compareTo(MARGS^params)) then -- on vérifie les parametres
                        error(mauvais_parametres, identc^txt, MARGS^nom);
                    end
                else
                    error(pas_methode, "ceci n'est pas une methode");
                end
            end
        else
            error(pas_classe, "ceci n'est pas une classe");
        end
    end
end
}
#gen {
local 
  instance : String;
  c : DTYPE;
do
   if MARGS^nom.equals("init") then -- je dois allouer de la memoire
      F^code := F^machine.genComment("je passe par init"); 
      c := ic.getType();
      match c with CLASSE then 
         instance := F^machine.genMallocInstance(c.getTaille());
	 -- ajouter l'instance dans la tds de la methode init 
         F^code := MARGS^code
                + instance -- code pour ajouter l'instance en parametre
                + F^machine.genCallMethod(MARGS^nom, ic.getTv() ,im.getNumero()); -- to call the function depending on his number (deplacement)
      			-- je dois load l etiquette 
	end 
   else
      F^code := F^machine.genComment("je passe pas init"); 
      c := ic.getType();
      F^code := MARGS^code
                + F^machine.genCallMethod(MARGS^nom, ic.getTv() ,im.getNumero()); -- to call the function depending on his number (deplacement)
   end
   F^est_adresse := false;
   F^adresse := null;
end
}

-- arguments appel de methode
MARGS ->  #parametres #gen ;
#gen {
do
  MARGS^code := "";
end
}

#parametres {
do
    MARGS^params := MARGS^hparams;
    MARGS^nom := "";
end
}

MARGS ->  MARG #parametres1 MARGS #parametres2  #gen  ;
#gen {
local
comment : String;
do
  comment := MARGS^machine.genComment("empilement des parametres");
  MARGS^code := comment + MARGS1^code + MARG^code;
end
}

#parametres1 {
do
    MARGS1^hparams := MARG^params;
end
}
#parametres2 {
do
    MARGS^params := MARGS1^params;
    MARGS^nom := MARG^nom + MARGS1^nom;
end
}

-- selecteur + arg
MARG -> ident dpts #lire_resultat E #parametres #gen ;
#gen {
local
do
  MARG^code := E^code;
end
}
#lire_resultat {
do
   E^lire_resultat := true;
end
}
#parametres {
do
    MARG^hparams.inserer(E^type);
    MARG^params := MARG^hparams;
    MARG^nom := ident^txt + ":";
end
}

-- selecteur sans arg
MARG -> ident #parametres #gen ;
#gen {
do
   MARG^code := "";
end
}
#parametres {
do
    MARG^params := MARG^hparams;
    MARG^nom := ident^txt;
end
}

--fin de MOC extension

end
